Index: beta/tools/gn/src/base/command_line.cc
===================================================================
--- beta.orig/tools/gn/src/base/command_line.cc
+++ beta/tools/gn/src/base/command_line.cc
@@ -7,7 +7,7 @@
 #include <algorithm>
 #include <iterator>
 #include <ostream>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_path.h"
 #include "base/logging.h"
@@ -187,8 +187,8 @@ CommandLine::~CommandLine() = default;
 // static
 void CommandLine::set_slash_is_not_a_switch() {
   // The last switch prefix should be slash, so adjust the size to skip it.
-  DCHECK(std::u16string_view(kSwitchPrefixes[std::size(kSwitchPrefixes) - 1]) ==
-         std::u16string_view(u"/"));
+  DCHECK(std::experimental::u16string_view(kSwitchPrefixes[std::size(kSwitchPrefixes) - 1]) ==
+         std::experimental::u16string_view(u"/"));
   switch_prefix_count = std::size(kSwitchPrefixes) - 1;
 }
 
@@ -283,17 +283,17 @@ void CommandLine::SetProgram(const FileP
 #endif
 }
 
-bool CommandLine::HasSwitch(const std::string_view& switch_string) const {
+bool CommandLine::HasSwitch(const std::experimental::string_view& switch_string) const {
   DCHECK_EQ(ToLowerASCII(switch_string), switch_string);
   return ContainsKey(switches_, switch_string);
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
-  return HasSwitch(std::string_view(switch_constant));
+  return HasSwitch(std::experimental::string_view(switch_constant));
 }
 
 std::string CommandLine::GetSwitchValueASCII(
-    const std::string_view& switch_string) const {
+    const std::experimental::string_view& switch_string) const {
   StringType value = GetSwitchValueNative(switch_string);
   if (!IsStringASCII(value)) {
     DLOG(WARNING) << "Value of switch (" << switch_string << ") must be ASCII.";
@@ -307,12 +307,12 @@ std::string CommandLine::GetSwitchValueA
 }
 
 FilePath CommandLine::GetSwitchValuePath(
-    const std::string_view& switch_string) const {
+    const std::experimental::string_view& switch_string) const {
   return FilePath(GetSwitchValueNative(switch_string));
 }
 
 CommandLine::StringType CommandLine::GetSwitchValueNative(
-    const std::string_view& switch_string) const {
+    const std::experimental::string_view& switch_string) const {
   DCHECK_EQ(ToLowerASCII(switch_string), switch_string);
   auto result = switches_.find(switch_string);
   return result == switches_.end() ? StringType() : result->second;
Index: beta/tools/gn/src/base/command_line.h
===================================================================
--- beta.orig/tools/gn/src/base/command_line.h
+++ beta/tools/gn/src/base/command_line.h
@@ -18,7 +18,7 @@
 #include <stddef.h>
 #include <map>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "util/build_config.h"
@@ -163,16 +163,16 @@ class CommandLine {
   // Switch names must be lowercase.
   // The second override provides an optimized version to avoid inlining codegen
   // at every callsite to find the length of the constant and construct a
-  // std::string_view.
-  bool HasSwitch(const std::string_view& switch_string) const;
+  // std::experimental::string_view.
+  bool HasSwitch(const std::experimental::string_view& switch_string) const;
   bool HasSwitch(const char switch_constant[]) const;
 
   // Returns the value associated with the given switch. If the switch has no
   // value or isn't present, this method returns the empty string.
   // Switch names must be lowercase.
-  std::string GetSwitchValueASCII(const std::string_view& switch_string) const;
-  FilePath GetSwitchValuePath(const std::string_view& switch_string) const;
-  StringType GetSwitchValueNative(const std::string_view& switch_string) const;
+  std::string GetSwitchValueASCII(const std::experimental::string_view& switch_string) const;
+  FilePath GetSwitchValuePath(const std::experimental::string_view& switch_string) const;
+  StringType GetSwitchValueNative(const std::experimental::string_view& switch_string) const;
 
   // Get a copy of all switches, along with their values.
   const SwitchMap& GetSwitches() const { return switches_; }
Index: beta/tools/gn/src/base/containers/span.h
===================================================================
--- beta.orig/tools/gn/src/base/containers/span.h
+++ beta/tools/gn/src/base/containers/span.h
@@ -88,7 +88,7 @@ using EnableIfSpanCompatibleContainer =
 // own the underlying memory, so care must be taken to ensure that a span does
 // not outlive the backing store.
 //
-// span is somewhat analogous to std::string_view, but with arbitrary element
+// span is somewhat analogous to std::experimental::string_view, but with arbitrary element
 // types, allowing mutation if T is non-const.
 //
 // span is implicitly convertible from C++ arrays, as well as most [1]
Index: beta/tools/gn/src/base/environment.cc
===================================================================
--- beta.orig/tools/gn/src/base/environment.cc
+++ beta/tools/gn/src/base/environment.cc
@@ -6,7 +6,7 @@
 
 #include <stddef.h>
 
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/memory/ptr_util.h"
@@ -26,7 +26,7 @@ namespace {
 
 class EnvironmentImpl : public Environment {
  public:
-  bool GetVar(std::string_view variable_name, std::string* result) override {
+  bool GetVar(std::experimental::string_view variable_name, std::string* result) override {
     if (GetVarImpl(variable_name, result))
       return true;
 
@@ -45,17 +45,17 @@ class EnvironmentImpl : public Environme
     return GetVarImpl(alternate_case_var, result);
   }
 
-  bool SetVar(std::string_view variable_name,
+  bool SetVar(std::experimental::string_view variable_name,
               const std::string& new_value) override {
     return SetVarImpl(variable_name, new_value);
   }
 
-  bool UnSetVar(std::string_view variable_name) override {
+  bool UnSetVar(std::experimental::string_view variable_name) override {
     return UnSetVarImpl(variable_name);
   }
 
  private:
-  bool GetVarImpl(std::string_view variable_name, std::string* result) {
+  bool GetVarImpl(std::experimental::string_view variable_name, std::string* result) {
 #if defined(OS_WIN)
     DWORD value_length = ::GetEnvironmentVariable(
         reinterpret_cast<LPCWSTR>(UTF8ToUTF16(variable_name).c_str()), nullptr,
@@ -81,7 +81,7 @@ class EnvironmentImpl : public Environme
 #endif
   }
 
-  bool SetVarImpl(std::string_view variable_name,
+  bool SetVarImpl(std::experimental::string_view variable_name,
                   const std::string& new_value) {
 #if defined(OS_WIN)
     // On success, a nonzero value is returned.
@@ -94,7 +94,7 @@ class EnvironmentImpl : public Environme
 #endif
   }
 
-  bool UnSetVarImpl(std::string_view variable_name) {
+  bool UnSetVarImpl(std::experimental::string_view variable_name) {
 #if defined(OS_WIN)
     // On success, a nonzero value is returned.
     return !!SetEnvironmentVariable(
@@ -142,7 +142,7 @@ std::unique_ptr<Environment> Environment
   return std::make_unique<EnvironmentImpl>();
 }
 
-bool Environment::HasVar(std::string_view variable_name) {
+bool Environment::HasVar(std::experimental::string_view variable_name) {
   return GetVar(variable_name, nullptr);
 }
 
Index: beta/tools/gn/src/base/environment.h
===================================================================
--- beta.orig/tools/gn/src/base/environment.h
+++ beta/tools/gn/src/base/environment.h
@@ -8,7 +8,7 @@
 #include <map>
 #include <memory>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "util/build_config.h"
 
@@ -31,17 +31,17 @@ class Environment {
 
   // Gets an environment variable's value and stores it in |result|.
   // Returns false if the key is unset.
-  virtual bool GetVar(std::string_view variable_name, std::string* result) = 0;
+  virtual bool GetVar(std::experimental::string_view variable_name, std::string* result) = 0;
 
   // Syntactic sugar for GetVar(variable_name, nullptr);
-  virtual bool HasVar(std::string_view variable_name);
+  virtual bool HasVar(std::experimental::string_view variable_name);
 
   // Returns true on success, otherwise returns false.
-  virtual bool SetVar(std::string_view variable_name,
+  virtual bool SetVar(std::experimental::string_view variable_name,
                       const std::string& new_value) = 0;
 
   // Returns true on success, otherwise returns false.
-  virtual bool UnSetVar(std::string_view variable_name) = 0;
+  virtual bool UnSetVar(std::experimental::string_view variable_name) = 0;
 };
 
 #if defined(OS_WIN)
Index: beta/tools/gn/src/base/files/file_path.cc
===================================================================
--- beta.orig/tools/gn/src/base/files/file_path.cc
+++ beta/tools/gn/src/base/files/file_path.cc
@@ -8,7 +8,7 @@
 
 #include <algorithm>
 #include <iterator>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/logging.h"
 #include "base/macros.h"
@@ -173,7 +173,7 @@ FilePath::FilePath(const FilePath& that)
 FilePath::FilePath(FilePath&& that) noexcept = default;
 
 FilePath::FilePath(StringViewType path) {
-  path_.assign(path);
+  path_.assign(path.data(), path.size());
   StringType::size_type nul_pos = path_.find(kStringTerminator);
   if (nul_pos != StringType::npos)
     path_.erase(nul_pos, StringType::npos);
@@ -403,12 +403,12 @@ FilePath FilePath::InsertBeforeExtension
 
   StringType ext = Extension();
   StringType ret = RemoveExtension().value();
-  ret.append(suffix);
+  ret.append(suffix.data(), suffix.size());
   ret.append(ext);
   return FilePath(ret);
 }
 
-FilePath FilePath::InsertBeforeExtensionASCII(std::string_view suffix) const {
+FilePath FilePath::InsertBeforeExtensionASCII(std::experimental::string_view suffix) const {
   DCHECK(IsStringASCII(suffix));
 #if defined(OS_WIN)
   return InsertBeforeExtension(ASCIIToUTF16(suffix));
@@ -431,7 +431,7 @@ FilePath FilePath::AddExtension(StringVi
       *(str.end() - 1) != kExtensionSeparator) {
     str.append(1, kExtensionSeparator);
   }
-  str.append(extension);
+  str.append(extension.data(), extension.size());
   return FilePath(str);
 }
 
@@ -448,7 +448,7 @@ FilePath FilePath::ReplaceExtension(Stri
   StringType str = no_ext.value();
   if (extension[0] != kExtensionSeparator)
     str.append(1, kExtensionSeparator);
-  str.append(extension);
+  str.append(extension.data(), extension.size());
   return FilePath(str);
 }
 
@@ -458,7 +458,7 @@ FilePath FilePath::Append(StringViewType
 
   StringType::size_type nul_pos = component.find(kStringTerminator);
   if (nul_pos != StringViewType::npos) {
-    without_nuls.assign(component.substr(0, nul_pos));
+    without_nuls.assign(component.substr(0, nul_pos).data(), nul_pos);
     appended = StringViewType(without_nuls);
   }
 
@@ -492,7 +492,7 @@ FilePath FilePath::Append(StringViewType
     }
   }
 
-  new_path.path_.append(appended);
+  new_path.path_.append(appended.data(), appended.size());
   return new_path;
 }
 
@@ -500,7 +500,7 @@ FilePath FilePath::Append(const FilePath
   return Append(component.value());
 }
 
-FilePath FilePath::AppendASCII(std::string_view component) const {
+FilePath FilePath::AppendASCII(std::experimental::string_view component) const {
   DCHECK(base::IsStringASCII(component));
 #if defined(OS_WIN)
   return Append(ASCIIToUTF16(component));
Index: beta/tools/gn/src/base/files/file_path.h
===================================================================
--- beta.orig/tools/gn/src/base/files/file_path.h
+++ beta/tools/gn/src/base/files/file_path.h
@@ -106,7 +106,7 @@
 
 #include <iosfwd>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/compiler_specific.h"
@@ -154,7 +154,7 @@ class FilePath {
 #endif  // OS_WIN
 
   using CharType = StringType::value_type;
-  using StringViewType = std::basic_string_view<CharType>;
+  using StringViewType = std::experimental::basic_string_view<CharType>;
 
   // Null-terminated array of separators used to separate components in
   // hierarchical paths.  Each character in this array is a valid separator,
@@ -285,7 +285,7 @@ class FilePath {
   // path == "C:\pics.old\jojo" suffix == " (1)", returns "C:\pics.old\jojo (1)"
   FilePath InsertBeforeExtension(StringViewType suffix) const
       WARN_UNUSED_RESULT;
-  FilePath InsertBeforeExtensionASCII(std::string_view suffix) const
+  FilePath InsertBeforeExtensionASCII(std::experimental::string_view suffix) const
       WARN_UNUSED_RESULT;
 
   // Adds |extension| to |file_name|. Returns the current FilePath if
@@ -313,7 +313,7 @@ class FilePath {
   // Linux, although it can use any 8-bit encoding for paths, we assume that
   // ASCII is a valid subset, regardless of the encoding, since many operating
   // system paths will always be ASCII.
-  FilePath AppendASCII(std::string_view component) const WARN_UNUSED_RESULT;
+  FilePath AppendASCII(std::experimental::string_view component) const WARN_UNUSED_RESULT;
 
   // Returns true if this FilePath contains an absolute path.  On Windows, an
   // absolute path begins with either a drive letter specification followed by
Index: beta/tools/gn/src/base/files/file_util.cc
===================================================================
--- beta.orig/tools/gn/src/base/files/file_util.cc
+++ beta/tools/gn/src/base/files/file_util.cc
@@ -11,7 +11,7 @@
 
 #include <fstream>
 #include <limits>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_enumerator.h"
 #include "base/files/file_path.h"
Index: beta/tools/gn/src/base/files/file_util_posix.cc
===================================================================
--- beta.orig/tools/gn/src/base/files/file_util_posix.cc
+++ beta/tools/gn/src/base/files/file_util_posix.cc
@@ -143,7 +143,7 @@ bool CopyFileContents(File* infile, File
 // Appends |mode_char| to |mode| before the optional character set encoding; see
 // https://www.gnu.org/software/libc/manual/html_node/Opening-Streams.html for
 // details.
-std::string AppendModeCharacter(std::string_view mode, char mode_char) {
+std::string AppendModeCharacter(std::experimental::string_view mode, char mode_char) {
   std::string result(mode);
   size_t comma_pos = result.find(',');
   result.insert(comma_pos == std::string::npos ? result.length() : comma_pos, 1,
@@ -332,7 +332,7 @@ bool ExecutableExistsInPath(Environment*
     return false;
   }
 
-  for (const std::string_view& cur_path :
+  for (const std::experimental::string_view& cur_path :
        SplitStringPiece(path, ":", KEEP_WHITESPACE, SPLIT_WANT_NONEMPTY)) {
     FilePath file(cur_path);
     int permissions;
Index: beta/tools/gn/src/base/files/file_util_win.cc
===================================================================
--- beta.orig/tools/gn/src/base/files/file_util_win.cc
+++ beta/tools/gn/src/base/files/file_util_win.cc
@@ -19,7 +19,7 @@
 #include <iterator>
 #include <limits>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_enumerator.h"
 #include "base/files/file_path.h"
@@ -196,7 +196,7 @@ FilePath MakeAbsoluteFilePath(const File
 bool DeleteFile(const FilePath& path, bool recursive) {
   static constexpr char kRecursive[] = "DeleteFile.Recursive";
   static constexpr char kNonRecursive[] = "DeleteFile.NonRecursive";
-  const std::string_view operation(recursive ? kRecursive : kNonRecursive);
+  const std::experimental::string_view operation(recursive ? kRecursive : kNonRecursive);
 
   // Metrics for delete failures tracked in https://crbug.com/599084. Delete may
   // fail for a number of reasons. Log some metrics relating to failures in the
Index: beta/tools/gn/src/base/json/json_parser.cc
===================================================================
--- beta.orig/tools/gn/src/base/json/json_parser.cc
+++ beta/tools/gn/src/base/json/json_parser.cc
@@ -5,7 +5,7 @@
 #include "base/json/json_parser.h"
 
 #include <cmath>
-#include <string_view>
+#include <experimental/string_view>
 #include <utility>
 #include <vector>
 
@@ -68,7 +68,7 @@ JSONParser::JSONParser(int options, int
 
 JSONParser::~JSONParser() = default;
 
-std::optional<Value> JSONParser::Parse(std::string_view input) {
+std::optional<Value> JSONParser::Parse(std::experimental::string_view input) {
   input_ = input;
   index_ = 0;
   line_number_ = 1;
@@ -163,30 +163,30 @@ std::string JSONParser::StringBuilder::D
 
 // JSONParser private //////////////////////////////////////////////////////////
 
-std::optional<std::string_view> JSONParser::PeekChars(int count) {
+std::optional<std::experimental::string_view> JSONParser::PeekChars(int count) {
   if (static_cast<size_t>(index_) + count > input_.length())
     return std::nullopt;
-  // Using std::string_view::substr() is significantly slower (according to
+  // Using std::experimental::string_view::substr() is significantly slower (according to
   // base_perftests) than constructing a substring manually.
-  return std::string_view(input_.data() + index_, count);
+  return std::experimental::string_view(input_.data() + index_, count);
 }
 
 std::optional<char> JSONParser::PeekChar() {
-  std::optional<std::string_view> chars = PeekChars(1);
+  std::optional<std::experimental::string_view> chars = PeekChars(1);
   if (chars)
     return (*chars)[0];
   return std::nullopt;
 }
 
-std::optional<std::string_view> JSONParser::ConsumeChars(int count) {
-  std::optional<std::string_view> chars = PeekChars(count);
+std::optional<std::experimental::string_view> JSONParser::ConsumeChars(int count) {
+  std::optional<std::experimental::string_view> chars = PeekChars(count);
   if (chars)
     index_ += count;
   return chars;
 }
 
 std::optional<char> JSONParser::ConsumeChar() {
-  std::optional<std::string_view> chars = ConsumeChars(1);
+  std::optional<std::experimental::string_view> chars = ConsumeChars(1);
   if (chars)
     return (*chars)[0];
   return std::nullopt;
@@ -268,7 +268,7 @@ void JSONParser::EatWhitespaceAndComment
 }
 
 bool JSONParser::EatComment() {
-  std::optional<std::string_view> comment_start = ConsumeChars(2);
+  std::optional<std::experimental::string_view> comment_start = ConsumeChars(2);
   if (!comment_start)
     return false;
 
@@ -444,7 +444,7 @@ bool JSONParser::ConsumeStringRaw(String
     return false;
   }
 
-  // StringBuilder will internally build a std::string_view unless a UTF-16
+  // StringBuilder will internally build a std::experimental::string_view unless a UTF-16
   // conversion occurs, at which point it will perform a copy into a
   // std::string.
   StringBuilder string(pos());
@@ -475,12 +475,12 @@ bool JSONParser::ConsumeStringRaw(String
     } else {
       // And if it is an escape sequence, the input string will be adjusted
       // (either by combining the two characters of an encoded escape sequence,
-      // or with a UTF conversion), so using std::string_view isn't possible --
+      // or with a UTF conversion), so using std::experimental::string_view isn't possible --
       // force a conversion.
       string.Convert();
 
       // Read past the escape '\' and ensure there's a character following.
-      std::optional<std::string_view> escape_sequence = ConsumeChars(2);
+      std::optional<std::experimental::string_view> escape_sequence = ConsumeChars(2);
       if (!escape_sequence) {
         ReportError(JSONReader::JSON_INVALID_ESCAPE, 0);
         return false;
@@ -558,7 +558,7 @@ bool JSONParser::ConsumeStringRaw(String
 
 // Entry is at the first X in \uXXXX.
 bool JSONParser::DecodeUTF16(uint32_t* out_code_point) {
-  std::optional<std::string_view> escape_sequence = ConsumeChars(4);
+  std::optional<std::experimental::string_view> escape_sequence = ConsumeChars(4);
   if (!escape_sequence)
     return false;
 
@@ -671,7 +671,7 @@ std::optional<Value> JSONParser::Consume
 
   index_ = exit_index;
 
-  std::string_view num_string(num_start, end_index - start_index);
+  std::experimental::string_view num_string(num_start, end_index - start_index);
 
   int num_int;
   if (StringToInt(num_string, &num_int))
@@ -717,7 +717,7 @@ std::optional<Value> JSONParser::Consume
   }
 }
 
-bool JSONParser::ConsumeIfMatch(std::string_view match) {
+bool JSONParser::ConsumeIfMatch(std::experimental::string_view match) {
   if (match == PeekChars(match.size())) {
     ConsumeChars(match.size());
     return true;
Index: beta/tools/gn/src/base/json/json_parser.h
===================================================================
--- beta.orig/tools/gn/src/base/json/json_parser.h
+++ beta/tools/gn/src/base/json/json_parser.h
@@ -11,7 +11,7 @@
 #include <memory>
 #include <optional>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/compiler_specific.h"
 #include "base/gtest_prod_util.h"
@@ -49,7 +49,7 @@ class JSONParser {
   // result as a Value.
   // Wrap this in base::FooValue::From() to check the Value is of type Foo and
   // convert to a FooValue at the same time.
-  std::optional<Value> Parse(std::string_view input);
+  std::optional<Value> Parse(std::experimental::string_view input);
 
   // Returns the error code.
   JSONReader::JsonParseError error_code() const;
@@ -83,7 +83,7 @@ class JSONParser {
   };
 
   // A helper class used for parsing strings. One optimization performed is to
-  // create base::Value with a std::string_view to avoid unnecessary std::string
+  // create base::Value with a std::experimental::string_view to avoid unnecessary std::string
   // copies. This is not possible if the input string needs to be decoded from
   // UTF-16 to UTF-8, or if an escape sequence causes characters to be skipped.
   // This class centralizes that logic.
@@ -104,9 +104,9 @@ class JSONParser {
     // converted, or by appending the UTF8 bytes for the code point.
     void Append(uint32_t point);
 
-    // Converts the builder from its default std::string_view to a full
+    // Converts the builder from its default std::experimental::string_view to a full
     // std::string, performing a copy. Once a builder is converted, it cannot be
-    // made a std::string_view again.
+    // made a std::experimental::string_view again.
     void Convert();
 
     // Returns the builder as a string, invalidating all state. This allows
@@ -128,14 +128,14 @@ class JSONParser {
 
   // Returns the next |count| bytes of the input stream, or nullopt if fewer
   // than |count| bytes remain.
-  std::optional<std::string_view> PeekChars(int count);
+  std::optional<std::experimental::string_view> PeekChars(int count);
 
   // Calls PeekChars() with a |count| of 1.
   std::optional<char> PeekChar();
 
   // Returns the next |count| bytes of the input stream, or nullopt if fewer
   // than |count| bytes remain, and advances the parser position by |count|.
-  std::optional<std::string_view> ConsumeChars(int count);
+  std::optional<std::experimental::string_view> ConsumeChars(int count);
 
   // Calls ConsumeChars() with a |count| of 1.
   std::optional<char> ConsumeChar();
@@ -198,7 +198,7 @@ class JSONParser {
   // consumed at the current parser position. Returns false if there are fewer
   // than |match|-length bytes or if the sequence does not match, and the
   // parser state is unchanged.
-  bool ConsumeIfMatch(std::string_view match);
+  bool ConsumeIfMatch(std::experimental::string_view match);
 
   // Sets the error information to |code| at the current column, based on
   // |index_| and |index_last_line_|, with an optional positive/negative
@@ -218,7 +218,7 @@ class JSONParser {
   const int max_depth_;
 
   // The input stream being parsed. Note: Not guaranteed to NUL-terminated.
-  std::string_view input_;
+  std::experimental::string_view input_;
 
   // The index in the input stream to which the parser is wound.
   int index_;
Index: beta/tools/gn/src/base/json/json_reader.cc
===================================================================
--- beta.orig/tools/gn/src/base/json/json_reader.cc
+++ beta/tools/gn/src/base/json/json_reader.cc
@@ -40,7 +40,7 @@ JSONReader::JSONReader(int options, int
 JSONReader::~JSONReader() = default;
 
 // static
-std::unique_ptr<Value> JSONReader::Read(std::string_view json,
+std::unique_ptr<Value> JSONReader::Read(std::experimental::string_view json,
                                         int options,
                                         int max_depth) {
   internal::JSONParser parser(options, max_depth);
@@ -50,7 +50,7 @@ std::unique_ptr<Value> JSONReader::Read(
 
 // static
 std::unique_ptr<Value> JSONReader::ReadAndReturnError(
-    std::string_view json,
+    std::experimental::string_view json,
     int options,
     int* error_code_out,
     std::string* error_msg_out,
@@ -102,7 +102,7 @@ std::string JSONReader::ErrorCodeToStrin
   return std::string();
 }
 
-std::unique_ptr<Value> JSONReader::ReadToValue(std::string_view json) {
+std::unique_ptr<Value> JSONReader::ReadToValue(std::experimental::string_view json) {
   std::optional<Value> value = parser_->Parse(json);
   return value ? std::make_unique<Value>(std::move(*value)) : nullptr;
 }
Index: beta/tools/gn/src/base/json/json_reader.h
===================================================================
--- beta.orig/tools/gn/src/base/json/json_reader.h
+++ beta/tools/gn/src/base/json/json_reader.h
@@ -30,7 +30,7 @@
 
 #include <memory>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace base {
 
@@ -93,7 +93,7 @@ class JSONReader {
   // If |json| is not a properly formed JSON string, returns nullptr.
   // Wrap this in base::FooValue::From() to check the Value is of type Foo and
   // convert to a FooValue at the same time.
-  static std::unique_ptr<Value> Read(std::string_view json,
+  static std::unique_ptr<Value> Read(std::experimental::string_view json,
                                      int options = JSON_PARSE_RFC,
                                      int max_depth = kStackMaxDepth);
 
@@ -102,7 +102,7 @@ class JSONReader {
   // an error code and a formatted error message (including error location if
   // appropriate). Otherwise, they will be unmodified.
   static std::unique_ptr<Value> ReadAndReturnError(
-      std::string_view json,
+      std::experimental::string_view json,
       int options,  // JSONParserOptions
       int* error_code_out,
       std::string* error_msg_out,
@@ -114,7 +114,7 @@ class JSONReader {
   static std::string ErrorCodeToString(JsonParseError error_code);
 
   // Non-static version of Read() above.
-  std::unique_ptr<Value> ReadToValue(std::string_view json);
+  std::unique_ptr<Value> ReadToValue(std::experimental::string_view json);
 
   // Returns the error code if the last call to ReadToValue() failed.
   // Returns JSON_NO_ERROR otherwise.
Index: beta/tools/gn/src/base/json/json_value_converter.h
===================================================================
--- beta.orig/tools/gn/src/base/json/json_value_converter.h
+++ beta/tools/gn/src/base/json/json_value_converter.h
@@ -9,7 +9,7 @@
 
 #include <memory>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/logging.h"
@@ -69,8 +69,8 @@
 //
 // Sometimes JSON format uses string representations for other types such
 // like enum, timestamp, or URL.  You can use RegisterCustomField method
-// and specify a function to convert a std::string_view to your type.
-//   bool ConvertFunc(std::string_view s, YourEnum* result) {
+// and specify a function to convert a std::experimental::string_view to your type.
+//   bool ConvertFunc(std::experimental::string_view s, YourEnum* result) {
 //     // do something and return true if succeed...
 //   }
 //   struct Message {
@@ -211,7 +211,7 @@ class ValueFieldConverter : public Value
 template <typename FieldType>
 class CustomFieldConverter : public ValueConverter<FieldType> {
  public:
-  typedef bool (*ConvertFunc)(std::string_view value, FieldType* field);
+  typedef bool (*ConvertFunc)(std::experimental::string_view value, FieldType* field);
 
   explicit CustomFieldConverter(ConvertFunc convert_func)
       : convert_func_(convert_func) {}
@@ -399,7 +399,7 @@ class JSONValueConverter {
   template <typename FieldType>
   void RegisterCustomField(const std::string& field_name,
                            FieldType StructType::*field,
-                           bool (*convert_func)(std::string_view, FieldType*)) {
+                           bool (*convert_func)(std::experimental::string_view, FieldType*)) {
     fields_.push_back(
         std::make_unique<internal::FieldConverter<StructType, FieldType>>(
             field_name, field,
Index: beta/tools/gn/src/base/json/string_escape.cc
===================================================================
--- beta.orig/tools/gn/src/base/json/string_escape.cc
+++ beta/tools/gn/src/base/json/string_escape.cc
@@ -116,40 +116,40 @@ bool EscapeJSONStringImpl(const S& str,
 
 }  // namespace
 
-bool EscapeJSONString(std::string_view str,
+bool EscapeJSONString(std::experimental::string_view str,
                       bool put_in_quotes,
                       std::string* dest) {
   return EscapeJSONStringImpl(str, put_in_quotes, dest);
 }
 
-bool EscapeJSONString(std::u16string_view str,
+bool EscapeJSONString(std::experimental::u16string_view str,
                       bool put_in_quotes,
                       std::string* dest) {
   return EscapeJSONStringImpl(str, put_in_quotes, dest);
 }
 
-std::string GetQuotedJSONString(std::string_view str) {
+std::string GetQuotedJSONString(std::experimental::string_view str) {
   std::string dest;
   bool ok = EscapeJSONStringImpl(str, true, &dest);
   DCHECK(ok);
   return dest;
 }
 
-std::string GetQuotedJSONString(std::u16string_view str) {
+std::string GetQuotedJSONString(std::experimental::u16string_view str) {
   std::string dest;
   bool ok = EscapeJSONStringImpl(str, true, &dest);
   DCHECK(ok);
   return dest;
 }
 
-std::string EscapeBytesAsInvalidJSONString(std::string_view str,
+std::string EscapeBytesAsInvalidJSONString(std::experimental::string_view str,
                                            bool put_in_quotes) {
   std::string dest;
 
   if (put_in_quotes)
     dest.push_back('"');
 
-  for (std::string_view::const_iterator it = str.begin(); it != str.end();
+  for (std::experimental::string_view::const_iterator it = str.begin(); it != str.end();
        ++it) {
     unsigned char c = *it;
     if (EscapeSpecialCodePoint(c, &dest))
Index: beta/tools/gn/src/base/json/string_escape.h
===================================================================
--- beta.orig/tools/gn/src/base/json/string_escape.h
+++ beta/tools/gn/src/base/json/string_escape.h
@@ -8,7 +8,7 @@
 #define BASE_JSON_STRING_ESCAPE_H_
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace base {
 
@@ -24,21 +24,21 @@ namespace base {
 //
 // If |put_in_quotes| is true, then a leading and trailing double-quote mark
 // will be appended to |dest| as well.
-bool EscapeJSONString(std::string_view str,
+bool EscapeJSONString(std::experimental::string_view str,
                       bool put_in_quotes,
                       std::string* dest);
 
-// Performs a similar function to the UTF-8 std::string_view version above,
+// Performs a similar function to the UTF-8 std::experimental::string_view version above,
 // converting UTF-16 code units to UTF-8 code units and escaping non-printing
 // control characters. On return, |dest| will contain a valid UTF-8 JSON string.
-bool EscapeJSONString(std::u16string_view str,
+bool EscapeJSONString(std::experimental::u16string_view str,
                       bool put_in_quotes,
                       std::string* dest);
 
 // Helper functions that wrap the above two functions but return the value
 // instead of appending. |put_in_quotes| is always true.
-std::string GetQuotedJSONString(std::string_view str);
-std::string GetQuotedJSONString(std::u16string_view str);
+std::string GetQuotedJSONString(std::experimental::string_view str);
+std::string GetQuotedJSONString(std::experimental::u16string_view str);
 
 // Given an arbitrary byte string |str|, this will escape all non-ASCII bytes
 // as \uXXXX escape sequences. This function is *NOT* meant to be used with
@@ -51,7 +51,7 @@ std::string GetQuotedJSONString(std::u16
 //
 // The output of this function takes the *appearance* of JSON but is not in
 // fact valid according to RFC 4627.
-std::string EscapeBytesAsInvalidJSONString(std::string_view str,
+std::string EscapeBytesAsInvalidJSONString(std::experimental::string_view str,
                                            bool put_in_quotes);
 
 }  // namespace base
Index: beta/tools/gn/src/base/logging.cc
===================================================================
--- beta.orig/tools/gn/src/base/logging.cc
+++ beta/tools/gn/src/base/logging.cc
@@ -43,7 +43,7 @@
 #include <iomanip>
 #include <ostream>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <utility>
 
 #include "base/posix/eintr_wrapper.h"
@@ -187,9 +187,9 @@ LogMessage::~LogMessage() {
 
 // writes the common header info to the stream
 void LogMessage::Init(const char* file, int line) {
-  std::string_view filename(file);
+  std::experimental::string_view filename(file);
   size_t last_slash_pos = filename.find_last_of("\\/");
-  if (last_slash_pos != std::string_view::npos)
+  if (last_slash_pos != std::experimental::string_view::npos)
     filename.remove_prefix(last_slash_pos + 1);
 
   // TODO(darin): It might be nice if the columns were fixed width.
Index: beta/tools/gn/src/base/logging.h
===================================================================
--- beta.orig/tools/gn/src/base/logging.h
+++ beta/tools/gn/src/base/logging.h
@@ -11,7 +11,7 @@
 #include <cstring>
 #include <sstream>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <type_traits>
 #include <utility>
 
Index: beta/tools/gn/src/base/md5.cc
===================================================================
--- beta.orig/tools/gn/src/base/md5.cc
+++ beta/tools/gn/src/base/md5.cc
@@ -169,7 +169,7 @@ void MD5Init(MD5Context* context) {
  * Update context to reflect the concatenation of another buffer full
  * of bytes.
  */
-void MD5Update(MD5Context* context, const std::string_view& data) {
+void MD5Update(MD5Context* context, const std::experimental::string_view& data) {
   struct Context* ctx = reinterpret_cast<struct Context*>(context);
   const uint8_t* buf = reinterpret_cast<const uint8_t*>(data.data());
   size_t len = data.size();
@@ -288,11 +288,11 @@ void MD5Sum(const void* data, size_t len
   MD5Context ctx;
   MD5Init(&ctx);
   MD5Update(&ctx,
-            std::string_view(reinterpret_cast<const char*>(data), length));
+            std::experimental::string_view(reinterpret_cast<const char*>(data), length));
   MD5Final(digest, &ctx);
 }
 
-std::string MD5String(const std::string_view& str) {
+std::string MD5String(const std::experimental::string_view& str) {
   MD5Digest digest;
   MD5Sum(str.data(), str.length(), &digest);
   return MD5DigestToBase16(digest);
Index: beta/tools/gn/src/base/md5.h
===================================================================
--- beta.orig/tools/gn/src/base/md5.h
+++ beta/tools/gn/src/base/md5.h
@@ -9,7 +9,7 @@
 #include <stdint.h>
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace base {
 
@@ -49,10 +49,10 @@ typedef char MD5Context[88];
 // MD5Update().
 void MD5Init(MD5Context* context);
 
-// For the given buffer of |data| as a std::string_view, updates the given MD5
+// For the given buffer of |data| as a std::experimental::string_view, updates the given MD5
 // context with the sum of the data. You can call this any number of times
 // during the computation, except that MD5Init() must have been called first.
-void MD5Update(MD5Context* context, const std::string_view& data);
+void MD5Update(MD5Context* context, const std::experimental::string_view& data);
 
 // Finalizes the MD5 operation and fills the buffer with the digest.
 void MD5Final(MD5Digest* digest, MD5Context* context);
@@ -70,7 +70,7 @@ std::string MD5DigestToBase16(const MD5D
 void MD5Sum(const void* data, size_t length, MD5Digest* digest);
 
 // Returns the MD5 (in hexadecimal) of a string.
-std::string MD5String(const std::string_view& str);
+std::string MD5String(const std::experimental::string_view& str);
 
 }  // namespace base
 
Index: beta/tools/gn/src/base/strings/string_number_conversions.cc
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_number_conversions.cc
+++ beta/tools/gn/src/base/strings/string_number_conversions.cc
@@ -270,38 +270,38 @@ template <typename ITERATOR>
 class BaseHexIteratorRangeToUInt64Traits
     : public BaseIteratorRangeToNumberTraits<ITERATOR, uint64_t, 16> {};
 
-typedef BaseHexIteratorRangeToIntTraits<std::string_view::const_iterator>
+typedef BaseHexIteratorRangeToIntTraits<std::experimental::string_view::const_iterator>
     HexIteratorRangeToIntTraits;
 
-typedef BaseHexIteratorRangeToUIntTraits<std::string_view::const_iterator>
+typedef BaseHexIteratorRangeToUIntTraits<std::experimental::string_view::const_iterator>
     HexIteratorRangeToUIntTraits;
 
-typedef BaseHexIteratorRangeToInt64Traits<std::string_view::const_iterator>
+typedef BaseHexIteratorRangeToInt64Traits<std::experimental::string_view::const_iterator>
     HexIteratorRangeToInt64Traits;
 
-typedef BaseHexIteratorRangeToUInt64Traits<std::string_view::const_iterator>
+typedef BaseHexIteratorRangeToUInt64Traits<std::experimental::string_view::const_iterator>
     HexIteratorRangeToUInt64Traits;
 
 template <typename VALUE, int BASE>
 class StringPieceToNumberTraits
-    : public BaseIteratorRangeToNumberTraits<std::string_view::const_iterator,
+    : public BaseIteratorRangeToNumberTraits<std::experimental::string_view::const_iterator,
                                              VALUE,
                                              BASE> {};
 
 template <typename VALUE>
-bool StringToIntImpl(std::string_view input, VALUE* output) {
+bool StringToIntImpl(std::experimental::string_view input, VALUE* output) {
   return IteratorRangeToNumber<StringPieceToNumberTraits<VALUE, 10>>::Invoke(
       input.begin(), input.end(), output);
 }
 
 template <typename VALUE, int BASE>
 class StringPiece16ToNumberTraits : public BaseIteratorRangeToNumberTraits<
-                                        std::u16string_view::const_iterator,
+                                        std::experimental::u16string_view::const_iterator,
                                         VALUE,
                                         BASE> {};
 
 template <typename VALUE>
-bool String16ToIntImpl(std::u16string_view input, VALUE* output) {
+bool String16ToIntImpl(std::experimental::u16string_view input, VALUE* output) {
   return IteratorRangeToNumber<StringPiece16ToNumberTraits<VALUE, 10>>::Invoke(
       input.begin(), input.end(), output);
 }
@@ -356,43 +356,43 @@ std::u16string NumberToString16(unsigned
   return IntToStringT<std::u16string, unsigned long long>::IntToString(value);
 }
 
-bool StringToInt(std::string_view input, int* output) {
+bool StringToInt(std::experimental::string_view input, int* output) {
   return StringToIntImpl(input, output);
 }
 
-bool StringToInt(std::u16string_view input, int* output) {
+bool StringToInt(std::experimental::u16string_view input, int* output) {
   return String16ToIntImpl(input, output);
 }
 
-bool StringToUint(std::string_view input, unsigned* output) {
+bool StringToUint(std::experimental::string_view input, unsigned* output) {
   return StringToIntImpl(input, output);
 }
 
-bool StringToUint(std::u16string_view input, unsigned* output) {
+bool StringToUint(std::experimental::u16string_view input, unsigned* output) {
   return String16ToIntImpl(input, output);
 }
 
-bool StringToInt64(std::string_view input, int64_t* output) {
+bool StringToInt64(std::experimental::string_view input, int64_t* output) {
   return StringToIntImpl(input, output);
 }
 
-bool StringToInt64(std::u16string_view input, int64_t* output) {
+bool StringToInt64(std::experimental::u16string_view input, int64_t* output) {
   return String16ToIntImpl(input, output);
 }
 
-bool StringToUint64(std::string_view input, uint64_t* output) {
+bool StringToUint64(std::experimental::string_view input, uint64_t* output) {
   return StringToIntImpl(input, output);
 }
 
-bool StringToUint64(std::u16string_view input, uint64_t* output) {
+bool StringToUint64(std::experimental::u16string_view input, uint64_t* output) {
   return String16ToIntImpl(input, output);
 }
 
-bool StringToSizeT(std::string_view input, size_t* output) {
+bool StringToSizeT(std::experimental::string_view input, size_t* output) {
   return StringToIntImpl(input, output);
 }
 
-bool StringToSizeT(std::u16string_view input, size_t* output) {
+bool StringToSizeT(std::experimental::u16string_view input, size_t* output) {
   return String16ToIntImpl(input, output);
 }
 
@@ -418,27 +418,27 @@ std::string HexEncode(const void* bytes,
   return ret;
 }
 
-bool HexStringToInt(std::string_view input, int* output) {
+bool HexStringToInt(std::experimental::string_view input, int* output) {
   return IteratorRangeToNumber<HexIteratorRangeToIntTraits>::Invoke(
       input.begin(), input.end(), output);
 }
 
-bool HexStringToUInt(std::string_view input, uint32_t* output) {
+bool HexStringToUInt(std::experimental::string_view input, uint32_t* output) {
   return IteratorRangeToNumber<HexIteratorRangeToUIntTraits>::Invoke(
       input.begin(), input.end(), output);
 }
 
-bool HexStringToInt64(std::string_view input, int64_t* output) {
+bool HexStringToInt64(std::experimental::string_view input, int64_t* output) {
   return IteratorRangeToNumber<HexIteratorRangeToInt64Traits>::Invoke(
       input.begin(), input.end(), output);
 }
 
-bool HexStringToUInt64(std::string_view input, uint64_t* output) {
+bool HexStringToUInt64(std::experimental::string_view input, uint64_t* output) {
   return IteratorRangeToNumber<HexIteratorRangeToUInt64Traits>::Invoke(
       input.begin(), input.end(), output);
 }
 
-bool HexStringToBytes(std::string_view input, std::vector<uint8_t>* output) {
+bool HexStringToBytes(std::experimental::string_view input, std::vector<uint8_t>* output) {
   DCHECK_EQ(output->size(), 0u);
   size_t count = input.size();
   if (count == 0 || (count % 2) != 0)
Index: beta/tools/gn/src/base/strings/string_number_conversions.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_number_conversions.h
+++ beta/tools/gn/src/base/strings/string_number_conversions.h
@@ -9,7 +9,7 @@
 #include <stdint.h>
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "util/build_config.h"
@@ -73,20 +73,20 @@ inline std::u16string Int64ToString16(in
 //  - Empty string.  |*output| will be set to 0.
 // WARNING: Will write to |output| even when returning false.
 //          Read the comments above carefully.
-bool StringToInt(std::string_view input, int* output);
-bool StringToInt(std::u16string_view input, int* output);
+bool StringToInt(std::experimental::string_view input, int* output);
+bool StringToInt(std::experimental::u16string_view input, int* output);
 
-bool StringToUint(std::string_view input, unsigned* output);
-bool StringToUint(std::u16string_view input, unsigned* output);
+bool StringToUint(std::experimental::string_view input, unsigned* output);
+bool StringToUint(std::experimental::u16string_view input, unsigned* output);
 
-bool StringToInt64(std::string_view input, int64_t* output);
-bool StringToInt64(std::u16string_view input, int64_t* output);
+bool StringToInt64(std::experimental::string_view input, int64_t* output);
+bool StringToInt64(std::experimental::u16string_view input, int64_t* output);
 
-bool StringToUint64(std::string_view input, uint64_t* output);
-bool StringToUint64(std::u16string_view input, uint64_t* output);
+bool StringToUint64(std::experimental::string_view input, uint64_t* output);
+bool StringToUint64(std::experimental::u16string_view input, uint64_t* output);
 
-bool StringToSizeT(std::string_view input, size_t* output);
-bool StringToSizeT(std::u16string_view input, size_t* output);
+bool StringToSizeT(std::experimental::string_view input, size_t* output);
+bool StringToSizeT(std::experimental::u16string_view input, size_t* output);
 
 // Hex encoding ----------------------------------------------------------------
 
@@ -101,30 +101,30 @@ std::string HexEncode(const void* bytes,
 // Best effort conversion, see StringToInt above for restrictions.
 // Will only successful parse hex values that will fit into |output|, i.e.
 // -0x80000000 < |input| < 0x7FFFFFFF.
-bool HexStringToInt(std::string_view input, int* output);
+bool HexStringToInt(std::experimental::string_view input, int* output);
 
 // Best effort conversion, see StringToInt above for restrictions.
 // Will only successful parse hex values that will fit into |output|, i.e.
 // 0x00000000 < |input| < 0xFFFFFFFF.
 // The string is not required to start with 0x.
-bool HexStringToUInt(std::string_view input, uint32_t* output);
+bool HexStringToUInt(std::experimental::string_view input, uint32_t* output);
 
 // Best effort conversion, see StringToInt above for restrictions.
 // Will only successful parse hex values that will fit into |output|, i.e.
 // -0x8000000000000000 < |input| < 0x7FFFFFFFFFFFFFFF.
-bool HexStringToInt64(std::string_view input, int64_t* output);
+bool HexStringToInt64(std::experimental::string_view input, int64_t* output);
 
 // Best effort conversion, see StringToInt above for restrictions.
 // Will only successful parse hex values that will fit into |output|, i.e.
 // 0x0000000000000000 < |input| < 0xFFFFFFFFFFFFFFFF.
 // The string is not required to start with 0x.
-bool HexStringToUInt64(std::string_view input, uint64_t* output);
+bool HexStringToUInt64(std::experimental::string_view input, uint64_t* output);
 
 // Similar to the previous functions, except that output is a vector of bytes.
 // |*output| will contain as many bytes as were successfully parsed prior to the
 // error.  There is no overflow, but input.size() must be evenly divisible by 2.
 // Leading 0x or +/- are not allowed.
-bool HexStringToBytes(std::string_view input, std::vector<uint8_t>* output);
+bool HexStringToBytes(std::experimental::string_view input, std::vector<uint8_t>* output);
 
 }  // namespace base
 
Index: beta/tools/gn/src/base/strings/string_split.cc
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_split.cc
+++ beta/tools/gn/src/base/strings/string_split.cc
@@ -16,13 +16,13 @@ namespace {
 
 // Returns either the ASCII or UTF-16 whitespace.
 template <typename char_type>
-std::basic_string_view<char_type> WhitespaceForType();
+std::experimental::basic_string_view<char_type> WhitespaceForType();
 template <>
-std::u16string_view WhitespaceForType<char16_t>() {
+std::experimental::u16string_view WhitespaceForType<char16_t>() {
   return kWhitespaceUTF16;
 }
 template <>
-std::string_view WhitespaceForType<char>() {
+std::experimental::string_view WhitespaceForType<char>() {
   return kWhitespaceASCII;
 }
 
@@ -30,37 +30,37 @@ std::string_view WhitespaceForType<char>
 // since this is the common case and can be made faster. This could have been
 // done with template specialization too, but would have been less clear.
 //
-// There is no corresponding FindFirstNotOf because std::string_view already
+// There is no corresponding FindFirstNotOf because std::experimental::string_view already
 // implements these different versions that do the optimized searching.
-size_t FindFirstOf(std::string_view piece, char c, size_t pos) {
+size_t FindFirstOf(std::experimental::string_view piece, char c, size_t pos) {
   return piece.find(c, pos);
 }
-size_t FindFirstOf(std::u16string_view piece, char16_t c, size_t pos) {
+size_t FindFirstOf(std::experimental::u16string_view piece, char16_t c, size_t pos) {
   return piece.find(c, pos);
 }
-size_t FindFirstOf(std::string_view piece,
-                   std::string_view one_of,
+size_t FindFirstOf(std::experimental::string_view piece,
+                   std::experimental::string_view one_of,
                    size_t pos) {
   return piece.find_first_of(one_of, pos);
 }
-size_t FindFirstOf(std::u16string_view piece,
-                   std::u16string_view one_of,
+size_t FindFirstOf(std::experimental::u16string_view piece,
+                   std::experimental::u16string_view one_of,
                    size_t pos) {
   return piece.find_first_of(one_of, pos);
 }
 
 // General string splitter template. Can take 8- or 16-bit input, can produce
-// the corresponding string or std::string_view output, and can take single- or
+// the corresponding string or std::experimental::string_view output, and can take single- or
 // multiple-character delimiters.
 //
 // DelimiterType is either a character (Str::value_type) or a string piece of
-// multiple characters (std::basic_string_view<char>). std::string_view has a
+// multiple characters (std::experimental::basic_string_view<char>). std::experimental::string_view has a
 // version of find for both of these cases, and the single-character version is
 // the most common and can be implemented faster, which is why this is a
 // template.
 template <typename char_type, typename OutputStringType, typename DelimiterType>
 static std::vector<OutputStringType> SplitStringT(
-    std::basic_string_view<char_type> str,
+    std::experimental::basic_string_view<char_type> str,
     DelimiterType delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type) {
@@ -68,7 +68,7 @@ static std::vector<OutputStringType> Spl
   if (str.empty())
     return result;
 
-  using ViewType = std::basic_string_view<char_type>;
+  using ViewType = std::experimental::basic_string_view<char_type>;
 
   size_t start = 0;
   while (start != ViewType::npos) {
@@ -92,7 +92,7 @@ static std::vector<OutputStringType> Spl
   return result;
 }
 
-bool AppendStringKeyValue(std::string_view input,
+bool AppendStringKeyValue(std::experimental::string_view input,
                           char delimiter,
                           StringPairs* result) {
   // Always append a new item regardless of success (it might be empty). The
@@ -105,28 +105,28 @@ bool AppendStringKeyValue(std::string_vi
   if (end_key_pos == std::string::npos) {
     return false;  // No delimiter.
   }
-  result_pair.first.assign(input.substr(0, end_key_pos));
+  result_pair.first.assign(input.substr(0, end_key_pos).data(), end_key_pos);
 
   // Find the value string.
-  std::string_view remains =
+  std::experimental::string_view remains =
       input.substr(end_key_pos, input.size() - end_key_pos);
   size_t begin_value_pos = remains.find_first_not_of(delimiter);
-  if (begin_value_pos == std::string_view::npos) {
+  if (begin_value_pos == std::experimental::string_view::npos) {
     return false;  // No value.
   }
   result_pair.second.assign(
-      remains.substr(begin_value_pos, remains.size() - begin_value_pos));
+      remains.substr(begin_value_pos, remains.size() - begin_value_pos).data(), remains.size() - begin_value_pos);
 
   return true;
 }
 
 template <typename char_type, typename OutputStringType>
-void SplitStringUsingSubstrT(std::basic_string_view<char_type> input,
-                             std::basic_string_view<char_type> delimiter,
+void SplitStringUsingSubstrT(std::experimental::basic_string_view<char_type> input,
+                             std::experimental::basic_string_view<char_type> delimiter,
                              WhitespaceHandling whitespace,
                              SplitResult result_type,
                              std::vector<OutputStringType>* result) {
-  using Piece = std::basic_string_view<char_type>;
+  using Piece = std::experimental::basic_string_view<char_type>;
   using size_type = typename Piece::size_type;
 
   result->clear();
@@ -147,68 +147,68 @@ void SplitStringUsingSubstrT(std::basic_
 
 }  // namespace
 
-std::vector<std::string> SplitString(std::string_view input,
-                                     std::string_view separators,
+std::vector<std::string> SplitString(std::experimental::string_view input,
+                                     std::experimental::string_view separators,
                                      WhitespaceHandling whitespace,
                                      SplitResult result_type) {
   if (separators.size() == 1) {
     return SplitStringT<char, std::string, char>(input, separators[0],
                                                  whitespace, result_type);
   }
-  return SplitStringT<char, std::string, std::string_view>(
+  return SplitStringT<char, std::string, std::experimental::string_view>(
       input, separators, whitespace, result_type);
 }
 
-std::vector<std::u16string> SplitString(std::u16string_view input,
-                                        std::u16string_view separators,
+std::vector<std::u16string> SplitString(std::experimental::u16string_view input,
+                                        std::experimental::u16string_view separators,
                                         WhitespaceHandling whitespace,
                                         SplitResult result_type) {
   if (separators.size() == 1) {
     return SplitStringT<char16_t, std::u16string, char16_t>(
         input, separators[0], whitespace, result_type);
   }
-  return SplitStringT<char16_t, std::u16string, std::u16string_view>(
+  return SplitStringT<char16_t, std::u16string, std::experimental::u16string_view>(
       input, separators, whitespace, result_type);
 }
 
-std::vector<std::string_view> SplitStringPiece(std::string_view input,
-                                               std::string_view separators,
+std::vector<std::experimental::string_view> SplitStringPiece(std::experimental::string_view input,
+                                               std::experimental::string_view separators,
                                                WhitespaceHandling whitespace,
                                                SplitResult result_type) {
   if (separators.size() == 1) {
-    return SplitStringT<char, std::string_view, char>(input, separators[0],
+    return SplitStringT<char, std::experimental::string_view, char>(input, separators[0],
                                                       whitespace, result_type);
   }
-  return SplitStringT<char, std::string_view, std::string_view>(
+  return SplitStringT<char, std::experimental::string_view, std::experimental::string_view>(
       input, separators, whitespace, result_type);
 }
 
-std::vector<std::u16string_view> SplitStringPiece(
-    std::u16string_view input,
-    std::u16string_view separators,
+std::vector<std::experimental::u16string_view> SplitStringPiece(
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view separators,
     WhitespaceHandling whitespace,
     SplitResult result_type) {
   if (separators.size() == 1) {
-    return SplitStringT<char16_t, std::u16string_view, char16_t>(
+    return SplitStringT<char16_t, std::experimental::u16string_view, char16_t>(
         input, separators[0], whitespace, result_type);
   }
-  return SplitStringT<char16_t, std::u16string_view, std::u16string_view>(
+  return SplitStringT<char16_t, std::experimental::u16string_view, std::experimental::u16string_view>(
       input, separators, whitespace, result_type);
 }
 
-bool SplitStringIntoKeyValuePairs(std::string_view input,
+bool SplitStringIntoKeyValuePairs(std::experimental::string_view input,
                                   char key_value_delimiter,
                                   char key_value_pair_delimiter,
                                   StringPairs* key_value_pairs) {
   key_value_pairs->clear();
 
-  std::vector<std::string_view> pairs =
+  std::vector<std::experimental::string_view> pairs =
       SplitStringPiece(input, std::string(1, key_value_pair_delimiter),
                        TRIM_WHITESPACE, SPLIT_WANT_NONEMPTY);
   key_value_pairs->reserve(pairs.size());
 
   bool success = true;
-  for (const std::string_view& pair : pairs) {
+  for (const std::experimental::string_view& pair : pairs) {
     if (!AppendStringKeyValue(pair, key_value_delimiter, key_value_pairs)) {
       // Don't return here, to allow for pairs without associated
       // value or key; just record that the split failed.
@@ -219,8 +219,8 @@ bool SplitStringIntoKeyValuePairs(std::s
 }
 
 std::vector<std::u16string> SplitStringUsingSubstr(
-    std::u16string_view input,
-    std::u16string_view delimiter,
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type) {
   std::vector<std::u16string> result;
@@ -228,8 +228,8 @@ std::vector<std::u16string> SplitStringU
   return result;
 }
 
-std::vector<std::string> SplitStringUsingSubstr(std::string_view input,
-                                                std::string_view delimiter,
+std::vector<std::string> SplitStringUsingSubstr(std::experimental::string_view input,
+                                                std::experimental::string_view delimiter,
                                                 WhitespaceHandling whitespace,
                                                 SplitResult result_type) {
   std::vector<std::string> result;
@@ -237,22 +237,22 @@ std::vector<std::string> SplitStringUsin
   return result;
 }
 
-std::vector<std::u16string_view> SplitStringPieceUsingSubstr(
-    std::u16string_view input,
-    std::u16string_view delimiter,
+std::vector<std::experimental::u16string_view> SplitStringPieceUsingSubstr(
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type) {
-  std::vector<std::u16string_view> result;
+  std::vector<std::experimental::u16string_view> result;
   SplitStringUsingSubstrT(input, delimiter, whitespace, result_type, &result);
   return result;
 }
 
-std::vector<std::string_view> SplitStringPieceUsingSubstr(
-    std::string_view input,
-    std::string_view delimiter,
+std::vector<std::experimental::string_view> SplitStringPieceUsingSubstr(
+    std::experimental::string_view input,
+    std::experimental::string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type) {
-  std::vector<std::string_view> result;
+  std::vector<std::experimental::string_view> result;
   SplitStringUsingSubstrT(input, delimiter, whitespace, result_type, &result);
   return result;
 }
Index: beta/tools/gn/src/base/strings/string_split.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_split.h
+++ beta/tools/gn/src/base/strings/string_split.h
@@ -6,7 +6,7 @@
 #define BASE_STRINGS_STRING_SPLIT_H_
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <utility>
 #include <vector>
 
@@ -40,12 +40,12 @@ enum SplitResult {
 //
 //   std::vector<std::string> tokens = base::SplitString(
 //       input, ",;", base::KEEP_WHITESPACE, base::SPLIT_WANT_ALL);
-std::vector<std::string> SplitString(std::string_view input,
-                                     std::string_view separators,
+std::vector<std::string> SplitString(std::experimental::string_view input,
+                                     std::experimental::string_view separators,
                                      WhitespaceHandling whitespace,
                                      SplitResult result_type);
-std::vector<std::u16string> SplitString(std::u16string_view input,
-                                        std::u16string_view separators,
+std::vector<std::u16string> SplitString(std::experimental::u16string_view input,
+                                        std::experimental::u16string_view separators,
                                         WhitespaceHandling whitespace,
                                         SplitResult result_type);
 
@@ -61,13 +61,13 @@ std::vector<std::u16string> SplitString(
 //                               base::KEEP_WHITESPACE,
 //                               base::SPLIT_WANT_NONEMPTY)) {
 //     ...
-std::vector<std::string_view> SplitStringPiece(std::string_view input,
-                                               std::string_view separators,
+std::vector<std::experimental::string_view> SplitStringPiece(std::experimental::string_view input,
+                                               std::experimental::string_view separators,
                                                WhitespaceHandling whitespace,
                                                SplitResult result_type);
-std::vector<std::u16string_view> SplitStringPiece(
-    std::u16string_view input,
-    std::u16string_view separators,
+std::vector<std::experimental::u16string_view> SplitStringPiece(
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view separators,
     WhitespaceHandling whitespace,
     SplitResult result_type);
 
@@ -77,7 +77,7 @@ using StringPairs = std::vector<std::pai
 // removes whitespace leading each key and trailing each value. Returns true
 // only if each pair has a non-empty key and value. |key_value_pairs| will
 // include ("","") pairs for entries without |key_value_delimiter|.
-bool SplitStringIntoKeyValuePairs(std::string_view input,
+bool SplitStringIntoKeyValuePairs(std::experimental::string_view input,
                                   char key_value_delimiter,
                                   char key_value_pair_delimiter,
                                   StringPairs* key_value_pairs);
@@ -85,12 +85,12 @@ bool SplitStringIntoKeyValuePairs(std::s
 // Similar to SplitString, but use a substring delimiter instead of a list of
 // characters that are all possible delimiters.
 std::vector<std::u16string> SplitStringUsingSubstr(
-    std::u16string_view input,
-    std::u16string_view delimiter,
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type);
-std::vector<std::string> SplitStringUsingSubstr(std::string_view input,
-                                                std::string_view delimiter,
+std::vector<std::string> SplitStringUsingSubstr(std::experimental::string_view input,
+                                                std::experimental::string_view delimiter,
                                                 WhitespaceHandling whitespace,
                                                 SplitResult result_type);
 
@@ -106,14 +106,14 @@ std::vector<std::string> SplitStringUsin
 //                                     base::KEEP_WHITESPACE,
 //                                     base::SPLIT_WANT_NONEMPTY)) {
 //     ...
-std::vector<std::u16string_view> SplitStringPieceUsingSubstr(
-    std::u16string_view input,
-    std::u16string_view delimiter,
+std::vector<std::experimental::u16string_view> SplitStringPieceUsingSubstr(
+    std::experimental::u16string_view input,
+    std::experimental::u16string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type);
-std::vector<std::string_view> SplitStringPieceUsingSubstr(
-    std::string_view input,
-    std::string_view delimiter,
+std::vector<std::experimental::string_view> SplitStringPieceUsingSubstr(
+    std::experimental::string_view input,
+    std::experimental::string_view delimiter,
     WhitespaceHandling whitespace,
     SplitResult result_type);
 
Index: beta/tools/gn/src/base/strings/string_tokenizer.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_tokenizer.h
+++ beta/tools/gn/src/base/strings/string_tokenizer.h
@@ -7,7 +7,7 @@
 
 #include <algorithm>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace base {
 
@@ -141,8 +141,8 @@ class StringTokenizerT {
   const_iterator token_begin() const { return token_begin_; }
   const_iterator token_end() const { return token_end_; }
   str token() const { return str(token_begin_, token_end_); }
-  std::basic_string_view<typename str::value_type> token_piece() const {
-    return std::basic_string_view<typename str::value_type>(
+  std::experimental::basic_string_view<typename str::value_type> token_piece() const {
+    return std::experimental::basic_string_view<typename str::value_type>(
         &*token_begin_, std::distance(token_begin_, token_end_));
   }
 
Index: beta/tools/gn/src/base/strings/string_util.cc
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_util.cc
+++ beta/tools/gn/src/base/strings/string_util.cc
@@ -90,7 +90,7 @@ namespace {
 
 template <typename StringType>
 StringType ToLowerASCIIImpl(
-    std::basic_string_view<typename StringType::value_type> str) {
+    std::experimental::basic_string_view<typename StringType::value_type> str) {
   StringType ret;
   ret.reserve(str.size());
   for (size_t i = 0; i < str.size(); i++)
@@ -100,7 +100,7 @@ StringType ToLowerASCIIImpl(
 
 template <typename StringType>
 StringType ToUpperASCIIImpl(
-    std::basic_string_view<typename StringType::value_type> str) {
+    std::experimental::basic_string_view<typename StringType::value_type> str) {
   StringType ret;
   ret.reserve(str.size());
   for (size_t i = 0; i < str.size(); i++)
@@ -110,26 +110,26 @@ StringType ToUpperASCIIImpl(
 
 }  // namespace
 
-std::string ToLowerASCII(std::string_view str) {
+std::string ToLowerASCII(std::experimental::string_view str) {
   return ToLowerASCIIImpl<std::string>(str);
 }
 
-std::u16string ToLowerASCII(std::u16string_view str) {
+std::u16string ToLowerASCII(std::experimental::u16string_view str) {
   return ToLowerASCIIImpl<std::u16string>(str);
 }
 
-std::string ToUpperASCII(std::string_view str) {
+std::string ToUpperASCII(std::experimental::string_view str) {
   return ToUpperASCIIImpl<std::string>(str);
 }
 
-std::u16string ToUpperASCII(std::u16string_view str) {
+std::u16string ToUpperASCII(std::experimental::u16string_view str) {
   return ToUpperASCIIImpl<std::u16string>(str);
 }
 
 template <class StringType>
 int CompareCaseInsensitiveASCIIT(
-    std::basic_string_view<typename StringType::value_type> a,
-    std::basic_string_view<typename StringType::value_type> b) {
+    std::experimental::basic_string_view<typename StringType::value_type> a,
+    std::experimental::basic_string_view<typename StringType::value_type> b) {
   // Find the first characters that aren't equal and compare them.  If the end
   // of one of the strings is found before a nonequal character, the lengths
   // of the strings are compared.
@@ -154,21 +154,21 @@ int CompareCaseInsensitiveASCIIT(
   return 1;
 }
 
-int CompareCaseInsensitiveASCII(std::string_view a, std::string_view b) {
+int CompareCaseInsensitiveASCII(std::experimental::string_view a, std::experimental::string_view b) {
   return CompareCaseInsensitiveASCIIT<std::string>(a, b);
 }
 
-int CompareCaseInsensitiveASCII(std::u16string_view a, std::u16string_view b) {
+int CompareCaseInsensitiveASCII(std::experimental::u16string_view a, std::experimental::u16string_view b) {
   return CompareCaseInsensitiveASCIIT<std::u16string>(a, b);
 }
 
-bool EqualsCaseInsensitiveASCII(std::string_view a, std::string_view b) {
+bool EqualsCaseInsensitiveASCII(std::experimental::string_view a, std::experimental::string_view b) {
   if (a.length() != b.length())
     return false;
   return CompareCaseInsensitiveASCIIT<std::string>(a, b) == 0;
 }
 
-bool EqualsCaseInsensitiveASCII(std::u16string_view a, std::u16string_view b) {
+bool EqualsCaseInsensitiveASCII(std::experimental::u16string_view a, std::experimental::u16string_view b) {
   if (a.length() != b.length())
     return false;
   return CompareCaseInsensitiveASCIIT<std::u16string>(a, b) == 0;
@@ -177,49 +177,49 @@ bool EqualsCaseInsensitiveASCII(std::u16
 template <class StringType>
 bool ReplaceCharsT(
     const StringType& input,
-    std::basic_string_view<typename StringType::value_type> find_any_of_these,
-    std::basic_string_view<typename StringType::value_type> replace_with,
+    std::experimental::basic_string_view<typename StringType::value_type> find_any_of_these,
+    std::experimental::basic_string_view<typename StringType::value_type> replace_with,
     StringType* output);
 
 bool ReplaceChars(const std::u16string& input,
-                  std::u16string_view replace_chars,
+                  std::experimental::u16string_view replace_chars,
                   const std::u16string& replace_with,
                   std::u16string* output) {
-  return ReplaceCharsT(input, replace_chars, std::u16string_view(replace_with),
+  return ReplaceCharsT(input, replace_chars, std::experimental::u16string_view(replace_with),
                        output);
 }
 
 bool ReplaceChars(const std::string& input,
-                  std::string_view replace_chars,
+                  std::experimental::string_view replace_chars,
                   const std::string& replace_with,
                   std::string* output) {
-  return ReplaceCharsT(input, replace_chars, std::string_view(replace_with),
+  return ReplaceCharsT(input, replace_chars, std::experimental::string_view(replace_with),
                        output);
 }
 
 bool RemoveChars(const std::u16string& input,
-                 std::u16string_view remove_chars,
+                 std::experimental::u16string_view remove_chars,
                  std::u16string* output) {
-  return ReplaceCharsT(input, remove_chars, std::u16string_view(), output);
+  return ReplaceCharsT(input, remove_chars, std::experimental::u16string_view(), output);
 }
 
 bool RemoveChars(const std::string& input,
-                 std::string_view remove_chars,
+                 std::experimental::string_view remove_chars,
                  std::string* output) {
-  return ReplaceCharsT(input, remove_chars, std::string_view(), output);
+  return ReplaceCharsT(input, remove_chars, std::experimental::string_view(), output);
 }
 
 template <typename Str>
 TrimPositions TrimStringT(
     const Str& input,
-    std::basic_string_view<typename Str::value_type> trim_chars,
+    std::experimental::basic_string_view<typename Str::value_type> trim_chars,
     TrimPositions positions,
     Str* output) {
   // Find the edges of leading/trailing whitespace as desired. Need to use
-  // a std::string_view version of input to be able to call find* on it with the
-  // std::string_view version of trim_chars (normally the trim_chars will be a
+  // a std::experimental::string_view version of input to be able to call find* on it with the
+  // std::experimental::string_view version of trim_chars (normally the trim_chars will be a
   // constant so avoid making a copy).
-  std::basic_string_view<typename Str::value_type> input_piece(input);
+  std::experimental::basic_string_view<typename Str::value_type> input_piece(input);
   const size_t last_char = input.length() - 1;
   const size_t first_good_char = (positions & TRIM_LEADING)
                                      ? input_piece.find_first_not_of(trim_chars)
@@ -248,26 +248,26 @@ TrimPositions TrimStringT(
 }
 
 bool TrimString(const std::u16string& input,
-                std::u16string_view trim_chars,
+                std::experimental::u16string_view trim_chars,
                 std::u16string* output) {
   return TrimStringT(input, trim_chars, TRIM_ALL, output) != TRIM_NONE;
 }
 
 bool TrimString(const std::string& input,
-                std::string_view trim_chars,
+                std::experimental::string_view trim_chars,
                 std::string* output) {
   return TrimStringT(input, trim_chars, TRIM_ALL, output) != TRIM_NONE;
 }
 
 template <typename char_type>
-std::basic_string_view<char_type> TrimStringPieceT(
-    std::basic_string_view<char_type> input,
-    std::basic_string_view<char_type> trim_chars,
+std::experimental::basic_string_view<char_type> TrimStringPieceT(
+    std::experimental::basic_string_view<char_type> input,
+    std::experimental::basic_string_view<char_type> trim_chars,
     TrimPositions positions) {
   size_t begin =
       (positions & TRIM_LEADING) ? input.find_first_not_of(trim_chars) : 0;
-  if (begin == std::basic_string_view<char_type>::npos)
-    return std::basic_string_view<char_type>();  // All trimmed.
+  if (begin == std::experimental::basic_string_view<char_type>::npos)
+    return std::experimental::basic_string_view<char_type>();  // All trimmed.
 
   size_t end = (positions & TRIM_TRAILING)
                    ? input.find_last_not_of(trim_chars) + 1
@@ -275,14 +275,14 @@ std::basic_string_view<char_type> TrimSt
   return input.substr(begin, end - begin);
 }
 
-std::u16string_view TrimString(std::u16string_view input,
-                               std::u16string_view trim_chars,
+std::experimental::u16string_view TrimString(std::experimental::u16string_view input,
+                               std::experimental::u16string_view trim_chars,
                                TrimPositions positions) {
   return TrimStringPieceT(input, trim_chars, positions);
 }
 
-std::string_view TrimString(std::string_view input,
-                            std::string_view trim_chars,
+std::experimental::string_view TrimString(std::experimental::string_view input,
+                            std::experimental::string_view trim_chars,
                             TrimPositions positions) {
   return TrimStringPieceT(input, trim_chars, positions);
 }
@@ -326,26 +326,26 @@ void TruncateUTF8ToByteSize(const std::s
 TrimPositions TrimWhitespace(const std::u16string& input,
                              TrimPositions positions,
                              std::u16string* output) {
-  return TrimStringT(input, std::u16string_view(kWhitespaceUTF16), positions,
+  return TrimStringT(input, std::experimental::u16string_view(kWhitespaceUTF16), positions,
                      output);
 }
 
-std::u16string_view TrimWhitespace(std::u16string_view input,
+std::experimental::u16string_view TrimWhitespace(std::experimental::u16string_view input,
                                    TrimPositions positions) {
-  return TrimStringPieceT(input, std::u16string_view(kWhitespaceUTF16),
+  return TrimStringPieceT(input, std::experimental::u16string_view(kWhitespaceUTF16),
                           positions);
 }
 
 TrimPositions TrimWhitespaceASCII(const std::string& input,
                                   TrimPositions positions,
                                   std::string* output) {
-  return TrimStringT(input, std::string_view(kWhitespaceASCII), positions,
+  return TrimStringT(input, std::experimental::string_view(kWhitespaceASCII), positions,
                      output);
 }
 
-std::string_view TrimWhitespaceASCII(std::string_view input,
+std::experimental::string_view TrimWhitespaceASCII(std::experimental::string_view input,
                                      TrimPositions positions) {
-  return TrimStringPieceT(input, std::string_view(kWhitespaceASCII), positions);
+  return TrimStringPieceT(input, std::experimental::string_view(kWhitespaceASCII), positions);
 }
 
 template <typename STR>
@@ -399,13 +399,13 @@ std::string CollapseWhitespaceASCII(cons
   return CollapseWhitespaceT(text, trim_sequences_with_line_breaks);
 }
 
-bool ContainsOnlyChars(std::string_view input, std::string_view characters) {
-  return input.find_first_not_of(characters) == std::string_view::npos;
+bool ContainsOnlyChars(std::experimental::string_view input, std::experimental::string_view characters) {
+  return input.find_first_not_of(characters) == std::experimental::string_view::npos;
 }
 
-bool ContainsOnlyChars(std::u16string_view input,
-                       std::u16string_view characters) {
-  return input.find_first_not_of(characters) == std::u16string_view::npos;
+bool ContainsOnlyChars(std::experimental::u16string_view input,
+                       std::experimental::u16string_view characters) {
+  return input.find_first_not_of(characters) == std::experimental::u16string_view::npos;
 }
 
 template <class Char>
@@ -438,15 +438,15 @@ inline bool DoIsStringASCII(const Char*
   return !(all_char_bits & non_ascii_bit_mask);
 }
 
-bool IsStringASCII(std::string_view str) {
+bool IsStringASCII(std::experimental::string_view str) {
   return DoIsStringASCII(str.data(), str.length());
 }
 
-bool IsStringASCII(std::u16string_view str) {
+bool IsStringASCII(std::experimental::u16string_view str) {
   return DoIsStringASCII(str.data(), str.length());
 }
 
-bool IsStringUTF8(std::string_view str) {
+bool IsStringUTF8(std::experimental::string_view str) {
   const char* src = str.data();
   int32_t src_len = static_cast<int32_t>(str.length());
   int32_t char_index = 0;
@@ -461,7 +461,7 @@ bool IsStringUTF8(std::string_view str)
 }
 
 // Implementation note: Normally this function will be called with a hardcoded
-// constant for the lowercase_ascii parameter. Constructing a std::string_view
+// constant for the lowercase_ascii parameter. Constructing a std::experimental::string_view
 // from a C constant requires running strlen, so the result will be two passes
 // through the buffers, one to file the length of lowercase_ascii, and one to
 // compare each letter.
@@ -474,11 +474,11 @@ bool IsStringUTF8(std::string_view str)
 //
 // The hardcoded strings are typically very short so it doesn't matter, and the
 // string piece gives additional flexibility for the caller (doesn't have to be
-// null terminated) so we choose the std::string_view route.
+// null terminated) so we choose the std::experimental::string_view route.
 template <typename Str>
 static inline bool DoLowerCaseEqualsASCII(
-    std::basic_string_view<typename Str::value_type> str,
-    std::string_view lowercase_ascii) {
+    std::experimental::basic_string_view<typename Str::value_type> str,
+    std::experimental::string_view lowercase_ascii) {
   if (str.size() != lowercase_ascii.size())
     return false;
   for (size_t i = 0; i < str.size(); i++) {
@@ -488,30 +488,30 @@ static inline bool DoLowerCaseEqualsASCI
   return true;
 }
 
-bool LowerCaseEqualsASCII(std::string_view str,
-                          std::string_view lowercase_ascii) {
+bool LowerCaseEqualsASCII(std::experimental::string_view str,
+                          std::experimental::string_view lowercase_ascii) {
   return DoLowerCaseEqualsASCII<std::string>(str, lowercase_ascii);
 }
 
-bool LowerCaseEqualsASCII(std::u16string_view str,
-                          std::string_view lowercase_ascii) {
+bool LowerCaseEqualsASCII(std::experimental::u16string_view str,
+                          std::experimental::string_view lowercase_ascii) {
   return DoLowerCaseEqualsASCII<std::u16string>(str, lowercase_ascii);
 }
 
-bool EqualsASCII(std::u16string_view str, std::string_view ascii) {
+bool EqualsASCII(std::experimental::u16string_view str, std::experimental::string_view ascii) {
   if (str.length() != ascii.length())
     return false;
   return std::equal(ascii.begin(), ascii.end(), str.begin());
 }
 
 template <typename char_type>
-bool StartsWithT(std::basic_string_view<char_type> str,
-                 std::basic_string_view<char_type> search_for,
+bool StartsWithT(std::experimental::basic_string_view<char_type> str,
+                 std::experimental::basic_string_view<char_type> search_for,
                  CompareCase case_sensitivity) {
   if (search_for.size() > str.size())
     return false;
 
-  std::basic_string_view<char_type> source = str.substr(0, search_for.size());
+  std::experimental::basic_string_view<char_type> source = str.substr(0, search_for.size());
 
   switch (case_sensitivity) {
     case CompareCase::SENSITIVE:
@@ -527,26 +527,26 @@ bool StartsWithT(std::basic_string_view<
   }
 }
 
-bool StartsWith(std::string_view str,
-                std::string_view search_for,
+bool StartsWith(std::experimental::string_view str,
+                std::experimental::string_view search_for,
                 CompareCase case_sensitivity) {
   return StartsWithT(str, search_for, case_sensitivity);
 }
 
-bool StartsWith(std::u16string_view str,
-                std::u16string_view search_for,
+bool StartsWith(std::experimental::u16string_view str,
+                std::experimental::u16string_view search_for,
                 CompareCase case_sensitivity) {
   return StartsWithT(str, search_for, case_sensitivity);
 }
 
 template <typename Str>
-bool EndsWithT(std::basic_string_view<typename Str::value_type> str,
-               std::basic_string_view<typename Str::value_type> search_for,
+bool EndsWithT(std::experimental::basic_string_view<typename Str::value_type> str,
+               std::experimental::basic_string_view<typename Str::value_type> search_for,
                CompareCase case_sensitivity) {
   if (search_for.size() > str.size())
     return false;
 
-  std::basic_string_view<typename Str::value_type> source =
+  std::experimental::basic_string_view<typename Str::value_type> source =
       str.substr(str.size() - search_for.size(), search_for.size());
 
   switch (case_sensitivity) {
@@ -564,14 +564,14 @@ bool EndsWithT(std::basic_string_view<ty
   }
 }
 
-bool EndsWith(std::string_view str,
-              std::string_view search_for,
+bool EndsWith(std::experimental::string_view str,
+              std::experimental::string_view search_for,
               CompareCase case_sensitivity) {
   return EndsWithT<std::string>(str, search_for, case_sensitivity);
 }
 
-bool EndsWith(std::u16string_view str,
-              std::u16string_view search_for,
+bool EndsWith(std::experimental::u16string_view str,
+              std::experimental::u16string_view search_for,
               CompareCase case_sensitivity) {
   return EndsWithT<std::u16string>(str, search_for, case_sensitivity);
 }
@@ -624,7 +624,7 @@ std::u16string FormatBytesUnlocalized(in
 // A Matcher for DoReplaceMatchesAfterOffset() that matches substrings.
 template <class StringType>
 struct SubstringMatcher {
-  std::basic_string_view<typename StringType::value_type> find_this;
+  std::experimental::basic_string_view<typename StringType::value_type> find_this;
 
   size_t Find(const StringType& input, size_t pos) {
     return input.find(find_this.data(), pos, find_this.length());
@@ -635,7 +635,7 @@ struct SubstringMatcher {
 // A Matcher for DoReplaceMatchesAfterOffset() that matches single characters.
 template <class StringType>
 struct CharacterMatcher {
-  std::basic_string_view<typename StringType::value_type> find_any_of_these;
+  std::experimental::basic_string_view<typename StringType::value_type> find_any_of_these;
 
   size_t Find(const StringType& input, size_t pos) {
     return input.find_first_of(find_any_of_these.data(), pos,
@@ -656,7 +656,7 @@ bool DoReplaceMatchesAfterOffset(
     StringType* str,
     size_t initial_offset,
     Matcher matcher,
-    std::basic_string_view<typename StringType::value_type> replace_with,
+    std::experimental::basic_string_view<typename StringType::value_type> replace_with,
     ReplaceType replace_type) {
   using CharTraits = typename StringType::traits_type;
 
@@ -798,8 +798,8 @@ bool DoReplaceMatchesAfterOffset(
 template <class StringType>
 bool ReplaceCharsT(
     const StringType& input,
-    std::basic_string_view<typename StringType::value_type> find_any_of_these,
-    std::basic_string_view<typename StringType::value_type> replace_with,
+    std::experimental::basic_string_view<typename StringType::value_type> find_any_of_these,
+    std::experimental::basic_string_view<typename StringType::value_type> replace_with,
     StringType* output) {
   // Commonly, this is called with output and input being the same string; in
   // that case, this assignment is inexpensive.
@@ -812,8 +812,8 @@ bool ReplaceCharsT(
 
 void ReplaceFirstSubstringAfterOffset(std::u16string* str,
                                       size_t start_offset,
-                                      std::u16string_view find_this,
-                                      std::u16string_view replace_with) {
+                                      std::experimental::u16string_view find_this,
+                                      std::experimental::u16string_view replace_with) {
   DoReplaceMatchesAfterOffset(str, start_offset,
                               SubstringMatcher<std::u16string>{find_this},
                               replace_with, ReplaceType::REPLACE_FIRST);
@@ -821,8 +821,8 @@ void ReplaceFirstSubstringAfterOffset(st
 
 void ReplaceFirstSubstringAfterOffset(std::string* str,
                                       size_t start_offset,
-                                      std::string_view find_this,
-                                      std::string_view replace_with) {
+                                      std::experimental::string_view find_this,
+                                      std::experimental::string_view replace_with) {
   DoReplaceMatchesAfterOffset(str, start_offset,
                               SubstringMatcher<std::string>{find_this},
                               replace_with, ReplaceType::REPLACE_FIRST);
@@ -830,8 +830,8 @@ void ReplaceFirstSubstringAfterOffset(st
 
 void ReplaceSubstringsAfterOffset(std::u16string* str,
                                   size_t start_offset,
-                                  std::u16string_view find_this,
-                                  std::u16string_view replace_with) {
+                                  std::experimental::u16string_view find_this,
+                                  std::experimental::u16string_view replace_with) {
   DoReplaceMatchesAfterOffset(str, start_offset,
                               SubstringMatcher<std::u16string>{find_this},
                               replace_with, ReplaceType::REPLACE_ALL);
@@ -839,8 +839,8 @@ void ReplaceSubstringsAfterOffset(std::u
 
 void ReplaceSubstringsAfterOffset(std::string* str,
                                   size_t start_offset,
-                                  std::string_view find_this,
-                                  std::string_view replace_with) {
+                                  std::experimental::string_view find_this,
+                                  std::experimental::string_view replace_with) {
   DoReplaceMatchesAfterOffset(str, start_offset,
                               SubstringMatcher<std::string>{find_this},
                               replace_with, ReplaceType::REPLACE_ALL);
@@ -873,7 +873,7 @@ char16_t* WriteInto(std::u16string* str,
 template <typename char_type, typename list_type>
 static std::basic_string<char_type> JoinStringT(
     const list_type& parts,
-    std::basic_string_view<char_type> sep) {
+    std::experimental::basic_string_view<char_type> sep) {
   if (parts.size() == 0)
     return std::basic_string<char_type>();
 
@@ -887,12 +887,12 @@ static std::basic_string<char_type> Join
 
   auto iter = parts.begin();
   DCHECK(iter != parts.end());
-  result.append(*iter);
+  result.append(iter->data(), iter->size());
   ++iter;
 
   for (; iter != parts.end(); ++iter) {
-    result.append(sep);
-    result.append(*iter);
+    result.append(sep.data(), sep.size());
+    result.append(iter->data(), iter->size());
   }
 
   // Sanity-check that we pre-allocated correctly.
@@ -902,12 +902,12 @@ static std::basic_string<char_type> Join
 }
 
 std::string JoinString(const std::vector<std::string>& parts,
-                       std::string_view separator) {
+                       std::experimental::string_view separator) {
   return JoinStringT(parts, separator);
 }
 
 std::u16string JoinString(const std::vector<std::u16string>& parts,
-                          std::u16string_view separator) {
+                          std::experimental::u16string_view separator) {
   return JoinStringT(parts, separator);
 }
 
@@ -916,23 +916,23 @@ std::u16string JoinString(const std::vec
 #pragma optimize("", on)
 #endif
 
-std::string JoinString(const std::vector<std::string_view>& parts,
-                       std::string_view separator) {
+std::string JoinString(const std::vector<std::experimental::string_view>& parts,
+                       std::experimental::string_view separator) {
   return JoinStringT(parts, separator);
 }
 
-std::u16string JoinString(const std::vector<std::u16string_view>& parts,
-                          std::u16string_view separator) {
+std::u16string JoinString(const std::vector<std::experimental::u16string_view>& parts,
+                          std::experimental::u16string_view separator) {
   return JoinStringT(parts, separator);
 }
 
-std::string JoinString(std::initializer_list<std::string_view> parts,
-                       std::string_view separator) {
+std::string JoinString(std::initializer_list<std::experimental::string_view> parts,
+                       std::experimental::string_view separator) {
   return JoinStringT(parts, separator);
 }
 
-std::u16string JoinString(std::initializer_list<std::u16string_view> parts,
-                          std::u16string_view separator) {
+std::u16string JoinString(std::initializer_list<std::experimental::u16string_view> parts,
+                          std::experimental::u16string_view separator) {
   return JoinStringT(parts, separator);
 }
 
@@ -998,7 +998,7 @@ std::u16string ReplaceStringPlaceholders
   return DoReplaceStringPlaceholders(format_string, subst, offsets);
 }
 
-std::string ReplaceStringPlaceholders(std::string_view format_string,
+std::string ReplaceStringPlaceholders(std::experimental::string_view format_string,
                                       const std::vector<std::string>& subst,
                                       std::vector<size_t>* offsets) {
   return DoReplaceStringPlaceholders(format_string, subst, offsets);
Index: beta/tools/gn/src/base/strings/string_util.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/string_util.h
+++ beta/tools/gn/src/base/strings/string_util.h
@@ -14,7 +14,7 @@
 
 #include <initializer_list>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/compiler_specific.h"
@@ -71,12 +71,12 @@ inline char16_t ToUpperASCII(char16_t c)
 }
 
 // Converts the given string to it's ASCII-lowercase equivalent.
-std::string ToLowerASCII(std::string_view str);
-std::u16string ToLowerASCII(std::u16string_view str);
+std::string ToLowerASCII(std::experimental::string_view str);
+std::u16string ToLowerASCII(std::experimental::u16string_view str);
 
 // Converts the given string to it's ASCII-uppercase equivalent.
-std::string ToUpperASCII(std::string_view str);
-std::u16string ToUpperASCII(std::u16string_view str);
+std::string ToUpperASCII(std::experimental::string_view str);
+std::u16string ToUpperASCII(std::experimental::u16string_view str);
 
 // Functor for case-insensitive ASCII comparisons for STL algorithms like
 // std::search.
@@ -101,14 +101,14 @@ struct CaseInsensitiveCompareASCII {
 // (unlike strcasecmp which can return values greater or less than 1/-1). For
 // full Unicode support, use base::i18n::ToLower or base::i18h::FoldCase
 // and then just call the normal string operators on the result.
-int CompareCaseInsensitiveASCII(std::string_view a, std::string_view b);
-int CompareCaseInsensitiveASCII(std::u16string_view a, std::u16string_view b);
+int CompareCaseInsensitiveASCII(std::experimental::string_view a, std::experimental::string_view b);
+int CompareCaseInsensitiveASCII(std::experimental::u16string_view a, std::experimental::u16string_view b);
 
 // Equality for ASCII case-insensitive comparisons. For full Unicode support,
 // use base::i18n::ToLower or base::i18h::FoldCase and then compare with either
 // == or !=.
-bool EqualsCaseInsensitiveASCII(std::string_view a, std::string_view b);
-bool EqualsCaseInsensitiveASCII(std::u16string_view a, std::u16string_view b);
+bool EqualsCaseInsensitiveASCII(std::experimental::string_view a, std::experimental::string_view b);
+bool EqualsCaseInsensitiveASCII(std::experimental::u16string_view a, std::experimental::u16string_view b);
 
 // Contains the set of characters representing whitespace in the corresponding
 // encoding. Null-terminated. The ASCII versions are the whitespaces as defined
@@ -124,10 +124,10 @@ extern const char kUtf8ByteOrderMark[];
 // if any characters were removed.  |remove_chars| must be null-terminated.
 // NOTE: Safe to use the same variable for both |input| and |output|.
 bool RemoveChars(const std::u16string& input,
-                 std::u16string_view remove_chars,
+                 std::experimental::u16string_view remove_chars,
                  std::u16string* output);
 bool RemoveChars(const std::string& input,
-                 std::string_view remove_chars,
+                 std::experimental::string_view remove_chars,
                  std::string* output);
 
 // Replaces characters in |replace_chars| from anywhere in |input| with
@@ -136,11 +136,11 @@ bool RemoveChars(const std::string& inpu
 // |replace_chars| must be null-terminated.
 // NOTE: Safe to use the same variable for both |input| and |output|.
 bool ReplaceChars(const std::u16string& input,
-                  std::u16string_view replace_chars,
+                  std::experimental::u16string_view replace_chars,
                   const std::u16string& replace_with,
                   std::u16string* output);
 bool ReplaceChars(const std::string& input,
-                  std::string_view replace_chars,
+                  std::experimental::string_view replace_chars,
                   const std::string& replace_with,
                   std::string* output);
 
@@ -158,19 +158,19 @@ enum TrimPositions {
 // It is safe to use the same variable for both |input| and |output| (this is
 // the normal usage to trim in-place).
 bool TrimString(const std::u16string& input,
-                std::u16string_view trim_chars,
+                std::experimental::u16string_view trim_chars,
                 std::u16string* output);
 bool TrimString(const std::string& input,
-                std::string_view trim_chars,
+                std::experimental::string_view trim_chars,
                 std::string* output);
 
-// std::string_view versions of the above. The returned pieces refer to the
+// std::experimental::string_view versions of the above. The returned pieces refer to the
 // original buffer.
-std::u16string_view TrimString(std::u16string_view input,
-                               std::u16string_view trim_chars,
+std::experimental::u16string_view TrimString(std::experimental::u16string_view input,
+                               std::experimental::u16string_view trim_chars,
                                TrimPositions positions);
-std::string_view TrimString(std::string_view input,
-                            std::string_view trim_chars,
+std::experimental::string_view TrimString(std::experimental::string_view input,
+                            std::experimental::string_view trim_chars,
                             TrimPositions positions);
 
 // Truncates a string to the nearest UTF-8 character that will leave
@@ -181,7 +181,7 @@ void TruncateUTF8ToByteSize(const std::s
 
 // Trims any whitespace from either end of the input string.
 //
-// The std::string_view versions return a substring referencing the input
+// The std::experimental::string_view versions return a substring referencing the input
 // buffer. The ASCII versions look only for ASCII whitespace.
 //
 // The std::string versions return where whitespace was found.
@@ -189,12 +189,12 @@ void TruncateUTF8ToByteSize(const std::s
 TrimPositions TrimWhitespace(const std::u16string& input,
                              TrimPositions positions,
                              std::u16string* output);
-std::u16string_view TrimWhitespace(std::u16string_view input,
+std::experimental::u16string_view TrimWhitespace(std::experimental::u16string_view input,
                                    TrimPositions positions);
 TrimPositions TrimWhitespaceASCII(const std::string& input,
                                   TrimPositions positions,
                                   std::string* output);
-std::string_view TrimWhitespaceASCII(std::string_view input,
+std::experimental::string_view TrimWhitespaceASCII(std::experimental::string_view input,
                                      TrimPositions positions);
 
 // Searches for CR or LF characters.  Removes all contiguous whitespace
@@ -212,9 +212,9 @@ std::string CollapseWhitespaceASCII(cons
 
 // Returns true if |input| is empty or contains only characters found in
 // |characters|.
-bool ContainsOnlyChars(std::string_view input, std::string_view characters);
-bool ContainsOnlyChars(std::u16string_view input,
-                       std::u16string_view characters);
+bool ContainsOnlyChars(std::experimental::string_view input, std::experimental::string_view characters);
+bool ContainsOnlyChars(std::experimental::u16string_view input,
+                       std::experimental::u16string_view characters);
 
 // Returns true if the specified string matches the criteria. How can a wide
 // string be 8-bit or UTF8? It contains only characters that are < 256 (in the
@@ -230,21 +230,21 @@ bool ContainsOnlyChars(std::u16string_vi
 //
 // IsStringASCII assumes the input is likely all ASCII, and does not leave early
 // if it is not the case.
-bool IsStringUTF8(std::string_view str);
-bool IsStringASCII(std::string_view str);
-bool IsStringASCII(std::u16string_view str);
+bool IsStringUTF8(std::experimental::string_view str);
+bool IsStringASCII(std::experimental::string_view str);
+bool IsStringASCII(std::experimental::u16string_view str);
 
 // Compare the lower-case form of the given string against the given
 // previously-lower-cased ASCII string (typically a constant).
-bool LowerCaseEqualsASCII(std::string_view str,
-                          std::string_view lowecase_ascii);
-bool LowerCaseEqualsASCII(std::u16string_view str,
-                          std::string_view lowecase_ascii);
+bool LowerCaseEqualsASCII(std::experimental::string_view str,
+                          std::experimental::string_view lowecase_ascii);
+bool LowerCaseEqualsASCII(std::experimental::u16string_view str,
+                          std::experimental::string_view lowecase_ascii);
 
 // Performs a case-sensitive string compare of the given 16-bit string against
 // the given 8-bit ASCII string (typically a constant). The behavior is
 // undefined if the |ascii| string is not ASCII.
-bool EqualsASCII(std::u16string_view str, std::string_view ascii);
+bool EqualsASCII(std::experimental::u16string_view str, std::experimental::string_view ascii);
 
 // Indicates case sensitivity of comparisons. Only ASCII case insensitivity
 // is supported. Full Unicode case-insensitive conversions would need to go in
@@ -259,17 +259,17 @@ enum class CompareCase {
   INSENSITIVE_ASCII,
 };
 
-bool StartsWith(std::string_view str,
-                std::string_view search_for,
+bool StartsWith(std::experimental::string_view str,
+                std::experimental::string_view search_for,
                 CompareCase case_sensitivity);
-bool StartsWith(std::u16string_view str,
-                std::u16string_view search_for,
+bool StartsWith(std::experimental::u16string_view str,
+                std::experimental::u16string_view search_for,
                 CompareCase case_sensitivity);
-bool EndsWith(std::string_view str,
-              std::string_view search_for,
+bool EndsWith(std::experimental::string_view str,
+              std::experimental::string_view search_for,
               CompareCase case_sensitivity);
-bool EndsWith(std::u16string_view str,
-              std::u16string_view search_for,
+bool EndsWith(std::experimental::u16string_view str,
+              std::experimental::u16string_view search_for,
               CompareCase case_sensitivity);
 
 // Determines the type of ASCII character, independent of locale (the C
@@ -321,12 +321,12 @@ std::u16string FormatBytesUnlocalized(in
 // |find_this| with |replace_with|.
 void ReplaceFirstSubstringAfterOffset(std::u16string* str,
                                       size_t start_offset,
-                                      std::u16string_view find_this,
-                                      std::u16string_view replace_with);
+                                      std::experimental::u16string_view find_this,
+                                      std::experimental::u16string_view replace_with);
 void ReplaceFirstSubstringAfterOffset(std::string* str,
                                       size_t start_offset,
-                                      std::string_view find_this,
-                                      std::string_view replace_with);
+                                      std::experimental::string_view find_this,
+                                      std::experimental::string_view replace_with);
 
 // Starting at |start_offset| (usually 0), look through |str| and replace all
 // instances of |find_this| with |replace_with|.
@@ -336,12 +336,12 @@ void ReplaceFirstSubstringAfterOffset(st
 //   std::replace(str.begin(), str.end(), 'a', 'b');
 void ReplaceSubstringsAfterOffset(std::u16string* str,
                                   size_t start_offset,
-                                  std::u16string_view find_this,
-                                  std::u16string_view replace_with);
+                                  std::experimental::u16string_view find_this,
+                                  std::experimental::u16string_view replace_with);
 void ReplaceSubstringsAfterOffset(std::string* str,
                                   size_t start_offset,
-                                  std::string_view find_this,
-                                  std::string_view replace_with);
+                                  std::experimental::string_view find_this,
+                                  std::experimental::string_view replace_with);
 
 // Reserves enough memory in |str| to accommodate |length_with_null| characters,
 // sets the size of |str| to |length_with_null - 1| characters, and returns a
@@ -370,28 +370,28 @@ char16_t* WriteInto(std::u16string* str,
 // of strings into a single string, inserting |separator| (which may be empty)
 // in between all elements.
 //
-// If possible, callers should build a vector of std::string_views and use the
-// std::string_view variant, so that they do not create unnecessary copies of
+// If possible, callers should build a vector of std::experimental::string_views and use the
+// std::experimental::string_view variant, so that they do not create unnecessary copies of
 // strings. For example, instead of using SplitString, modifying the vector,
 // then using JoinString, use SplitStringPiece followed by JoinString so that no
 // copies of those strings are created until the final join operation.
 //
 // Use StrCat (in base/strings/strcat.h) if you don't need a separator.
 std::string JoinString(const std::vector<std::string>& parts,
-                       std::string_view separator);
+                       std::experimental::string_view separator);
 std::u16string JoinString(const std::vector<std::u16string>& parts,
-                          std::u16string_view separator);
-std::string JoinString(const std::vector<std::string_view>& parts,
-                       std::string_view separator);
-std::u16string JoinString(const std::vector<std::u16string_view>& parts,
-                          std::u16string_view separator);
+                          std::experimental::u16string_view separator);
+std::string JoinString(const std::vector<std::experimental::string_view>& parts,
+                       std::experimental::string_view separator);
+std::u16string JoinString(const std::vector<std::experimental::u16string_view>& parts,
+                          std::experimental::u16string_view separator);
 // Explicit initializer_list overloads are required to break ambiguity when used
 // with a literal initializer list (otherwise the compiler would not be able to
-// decide between the string and std::string_view overloads).
-std::string JoinString(std::initializer_list<std::string_view> parts,
-                       std::string_view separator);
-std::u16string JoinString(std::initializer_list<std::u16string_view> parts,
-                          std::u16string_view separator);
+// decide between the string and std::experimental::string_view overloads).
+std::string JoinString(std::initializer_list<std::experimental::string_view> parts,
+                       std::experimental::string_view separator);
+std::u16string JoinString(std::initializer_list<std::experimental::u16string_view> parts,
+                          std::experimental::u16string_view separator);
 
 // Replace $1-$2-$3..$9 in the format string with values from |subst|.
 // Additionally, any number of consecutive '$' characters is replaced by that
@@ -402,7 +402,7 @@ std::u16string ReplaceStringPlaceholders
     const std::vector<std::u16string>& subst,
     std::vector<size_t>* offsets);
 
-std::string ReplaceStringPlaceholders(std::string_view format_string,
+std::string ReplaceStringPlaceholders(std::experimental::string_view format_string,
                                       const std::vector<std::string>& subst,
                                       std::vector<size_t>* offsets);
 
Index: beta/tools/gn/src/base/strings/utf_offset_string_conversions.cc
===================================================================
--- beta.orig/tools/gn/src/base/strings/utf_offset_string_conversions.cc
+++ beta/tools/gn/src/base/strings/utf_offset_string_conversions.cc
@@ -8,7 +8,7 @@
 
 #include <algorithm>
 #include <memory>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/logging.h"
 #include "base/strings/utf_string_conversion_utils.h"
@@ -228,7 +228,7 @@ bool UTF8ToUTF16WithAdjustments(
 }
 
 std::u16string UTF8ToUTF16WithAdjustments(
-    const std::string_view& utf8,
+    const std::experimental::string_view& utf8,
     base::OffsetAdjuster::Adjustments* adjustments) {
   std::u16string result;
   UTF8ToUTF16WithAdjustments(utf8.data(), utf8.length(), &result, adjustments);
@@ -236,7 +236,7 @@ std::u16string UTF8ToUTF16WithAdjustment
 }
 
 std::u16string UTF8ToUTF16AndAdjustOffsets(
-    const std::string_view& utf8,
+    const std::experimental::string_view& utf8,
     std::vector<size_t>* offsets_for_adjustment) {
   for (size_t& offset : *offsets_for_adjustment) {
     if (offset > utf8.length())
@@ -249,7 +249,7 @@ std::u16string UTF8ToUTF16AndAdjustOffse
 }
 
 std::string UTF16ToUTF8AndAdjustOffsets(
-    const std::u16string_view& utf16,
+    const std::experimental::u16string_view& utf16,
     std::vector<size_t>* offsets_for_adjustment) {
   for (size_t& offset : *offsets_for_adjustment) {
     if (offset > utf16.length())
Index: beta/tools/gn/src/base/strings/utf_offset_string_conversions.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/utf_offset_string_conversions.h
+++ beta/tools/gn/src/base/strings/utf_offset_string_conversions.h
@@ -8,7 +8,7 @@
 #include <stddef.h>
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 namespace base {
@@ -93,17 +93,17 @@ bool UTF8ToUTF16WithAdjustments(const ch
                                 std::u16string* output,
                                 base::OffsetAdjuster::Adjustments* adjustments);
 std::u16string UTF8ToUTF16WithAdjustments(
-    const std::string_view& utf8,
+    const std::experimental::string_view& utf8,
     base::OffsetAdjuster::Adjustments* adjustments);
 // As above, but instead internally examines the adjustments and applies them
 // to |offsets_for_adjustment|.  Input offsets greater than the length of the
 // input string will be set to std::u16string::npos.  See comments by
 // AdjustOffsets().
 std::u16string UTF8ToUTF16AndAdjustOffsets(
-    const std::string_view& utf8,
+    const std::experimental::string_view& utf8,
     std::vector<size_t>* offsets_for_adjustment);
 std::string UTF16ToUTF8AndAdjustOffsets(
-    const std::u16string_view& utf16,
+    const std::experimental::u16string_view& utf16,
     std::vector<size_t>* offsets_for_adjustment);
 
 }  // namespace base
Index: beta/tools/gn/src/base/strings/utf_string_conversions.cc
===================================================================
--- beta.orig/tools/gn/src/base/strings/utf_string_conversions.cc
+++ beta/tools/gn/src/base/strings/utf_string_conversions.cc
@@ -6,7 +6,7 @@
 
 #include <stdint.h>
 
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversion_utils.h"
@@ -157,10 +157,10 @@ bool UTFConversion(const InputString& sr
 // UTF16 <-> UTF8 --------------------------------------------------------------
 
 bool UTF8ToUTF16(const char* src, size_t src_len, std::u16string* output) {
-  return UTFConversion(std::string_view(src, src_len), output);
+  return UTFConversion(std::experimental::string_view(src, src_len), output);
 }
 
-std::u16string UTF8ToUTF16(std::string_view utf8) {
+std::u16string UTF8ToUTF16(std::experimental::string_view utf8) {
   std::u16string ret;
   // Ignore the success flag of this call, it will do the best it can for
   // invalid input, which is what we want here.
@@ -169,10 +169,10 @@ std::u16string UTF8ToUTF16(std::string_v
 }
 
 bool UTF16ToUTF8(const char16_t* src, size_t src_len, std::string* output) {
-  return UTFConversion(std::u16string_view(src, src_len), output);
+  return UTFConversion(std::experimental::u16string_view(src, src_len), output);
 }
 
-std::string UTF16ToUTF8(std::u16string_view utf16) {
+std::string UTF16ToUTF8(std::experimental::u16string_view utf16) {
   std::string ret;
   // Ignore the success flag of this call, it will do the best it can for
   // invalid input, which is what we want here.
@@ -182,12 +182,12 @@ std::string UTF16ToUTF8(std::u16string_v
 
 // ASCII <-> UTF-16 -----------------------------------------------------------
 
-std::u16string ASCIIToUTF16(std::string_view ascii) {
+std::u16string ASCIIToUTF16(std::experimental::string_view ascii) {
   DCHECK(IsStringASCII(ascii)) << ascii;
   return std::u16string(ascii.begin(), ascii.end());
 }
 
-std::string UTF16ToASCII(std::u16string_view utf16) {
+std::string UTF16ToASCII(std::experimental::u16string_view utf16) {
   DCHECK(IsStringASCII(utf16)) << UTF16ToUTF8(utf16);
   return std::string(utf16.begin(), utf16.end());
 }
Index: beta/tools/gn/src/base/strings/utf_string_conversions.h
===================================================================
--- beta.orig/tools/gn/src/base/strings/utf_string_conversions.h
+++ beta/tools/gn/src/base/strings/utf_string_conversions.h
@@ -8,22 +8,22 @@
 #include <stddef.h>
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace base {
 
 bool UTF8ToUTF16(const char* src, size_t src_len, std::u16string* output);
-std::u16string UTF8ToUTF16(std::string_view utf8);
+std::u16string UTF8ToUTF16(std::experimental::string_view utf8);
 bool UTF16ToUTF8(const char16_t* src, size_t src_len, std::string* output);
-std::string UTF16ToUTF8(std::u16string_view utf16);
+std::string UTF16ToUTF8(std::experimental::u16string_view utf16);
 
 // This converts an ASCII string, typically a hardcoded constant, to a UTF16
 // string.
-std::u16string ASCIIToUTF16(std::string_view ascii);
+std::u16string ASCIIToUTF16(std::experimental::string_view ascii);
 
 // Converts to 7-bit ASCII by truncating. The result must be known to be ASCII
 // beforehand.
-std::string UTF16ToASCII(std::u16string_view utf16);
+std::string UTF16ToASCII(std::experimental::u16string_view utf16);
 
 }  // namespace base
 
Index: beta/tools/gn/src/base/values.cc
===================================================================
--- beta.orig/tools/gn/src/base/values.cc
+++ beta/tools/gn/src/base/values.cc
@@ -131,7 +131,7 @@ Value::Value(int in_int) : type_(Type::I
 
 Value::Value(const char* in_string) : Value(std::string(in_string)) {}
 
-Value::Value(std::string_view in_string) : Value(std::string(in_string)) {}
+Value::Value(std::experimental::string_view in_string) : Value(std::string(in_string)) {}
 
 Value::Value(std::string&& in_string) noexcept
     : type_(Type::STRING), string_value_(std::move(in_string)) {
@@ -139,9 +139,9 @@ Value::Value(std::string&& in_string) no
 }
 
 Value::Value(const char16_t* in_string16)
-    : Value(std::u16string_view(in_string16)) {}
+    : Value(std::experimental::u16string_view(in_string16)) {}
 
-Value::Value(std::u16string_view in_string16)
+Value::Value(std::experimental::u16string_view in_string16)
     : Value(UTF16ToUTF8(in_string16)) {}
 
 Value::Value(const BlobStorage& in_blob)
@@ -240,11 +240,11 @@ const Value::ListStorage& Value::GetList
   return list_;
 }
 
-Value* Value::FindKey(std::string_view key) {
+Value* Value::FindKey(std::experimental::string_view key) {
   return const_cast<Value*>(static_cast<const Value*>(this)->FindKey(key));
 }
 
-const Value* Value::FindKey(std::string_view key) const {
+const Value* Value::FindKey(std::experimental::string_view key) const {
   CHECK(is_dict());
   auto found = dict_.find(key);
   if (found == dict_.end())
@@ -252,28 +252,28 @@ const Value* Value::FindKey(std::string_
   return found->second.get();
 }
 
-Value* Value::FindKeyOfType(std::string_view key, Type type) {
+Value* Value::FindKeyOfType(std::experimental::string_view key, Type type) {
   return const_cast<Value*>(
       static_cast<const Value*>(this)->FindKeyOfType(key, type));
 }
 
-const Value* Value::FindKeyOfType(std::string_view key, Type type) const {
+const Value* Value::FindKeyOfType(std::experimental::string_view key, Type type) const {
   const Value* result = FindKey(key);
   if (!result || result->type() != type)
     return nullptr;
   return result;
 }
 
-bool Value::RemoveKey(std::string_view key) {
+bool Value::RemoveKey(std::experimental::string_view key) {
   CHECK(is_dict());
   // NOTE: Can't directly return dict_->erase(key) due to MSVC warning C4800.
   return dict_.erase(key) != 0;
 }
 
-Value* Value::SetKey(std::string_view key, Value value) {
+Value* Value::SetKey(std::experimental::string_view key, Value value) {
   CHECK(is_dict());
   // NOTE: We can't use |insert_or_assign| here, as only |try_emplace| does
-  // an explicit conversion from std::string_view to std::string if necessary.
+  // an explicit conversion from std::experimental::string_view to std::string if necessary.
   auto val_ptr = std::make_unique<Value>(std::move(value));
   auto result = dict_.try_emplace(key, std::move(val_ptr));
   if (!result.second) {
@@ -292,50 +292,50 @@ Value* Value::SetKey(std::string&& key,
 }
 
 Value* Value::SetKey(const char* key, Value value) {
-  return SetKey(std::string_view(key), std::move(value));
+  return SetKey(std::experimental::string_view(key), std::move(value));
 }
 
-Value* Value::FindPath(std::initializer_list<std::string_view> path) {
+Value* Value::FindPath(std::initializer_list<std::experimental::string_view> path) {
   return const_cast<Value*>(const_cast<const Value*>(this)->FindPath(path));
 }
 
-Value* Value::FindPath(span<const std::string_view> path) {
+Value* Value::FindPath(span<const std::experimental::string_view> path) {
   return const_cast<Value*>(const_cast<const Value*>(this)->FindPath(path));
 }
 
 const Value* Value::FindPath(
-    std::initializer_list<std::string_view> path) const {
+    std::initializer_list<std::experimental::string_view> path) const {
   DCHECK_GE(path.size(), 2u) << "Use FindKey() for a path of length 1.";
   return FindPath(make_span(path.begin(), path.size()));
 }
 
-const Value* Value::FindPath(span<const std::string_view> path) const {
+const Value* Value::FindPath(span<const std::experimental::string_view> path) const {
   const Value* cur = this;
-  for (const std::string_view component : path) {
+  for (const std::experimental::string_view component : path) {
     if (!cur->is_dict() || (cur = cur->FindKey(component)) == nullptr)
       return nullptr;
   }
   return cur;
 }
 
-Value* Value::FindPathOfType(std::initializer_list<std::string_view> path,
+Value* Value::FindPathOfType(std::initializer_list<std::experimental::string_view> path,
                              Type type) {
   return const_cast<Value*>(
       const_cast<const Value*>(this)->FindPathOfType(path, type));
 }
 
-Value* Value::FindPathOfType(span<const std::string_view> path, Type type) {
+Value* Value::FindPathOfType(span<const std::experimental::string_view> path, Type type) {
   return const_cast<Value*>(
       const_cast<const Value*>(this)->FindPathOfType(path, type));
 }
 
-const Value* Value::FindPathOfType(std::initializer_list<std::string_view> path,
+const Value* Value::FindPathOfType(std::initializer_list<std::experimental::string_view> path,
                                    Type type) const {
   DCHECK_GE(path.size(), 2u) << "Use FindKeyOfType() for a path of length 1.";
   return FindPathOfType(make_span(path.begin(), path.size()), type);
 }
 
-const Value* Value::FindPathOfType(span<const std::string_view> path,
+const Value* Value::FindPathOfType(span<const std::experimental::string_view> path,
                                    Type type) const {
   const Value* result = FindPath(path);
   if (!result || result->type() != type)
@@ -343,25 +343,25 @@ const Value* Value::FindPathOfType(span<
   return result;
 }
 
-Value* Value::SetPath(std::initializer_list<std::string_view> path,
+Value* Value::SetPath(std::initializer_list<std::experimental::string_view> path,
                       Value value) {
   DCHECK_GE(path.size(), 2u) << "Use SetKey() for a path of length 1.";
   return SetPath(make_span(path.begin(), path.size()), std::move(value));
 }
 
-Value* Value::SetPath(span<const std::string_view> path, Value value) {
+Value* Value::SetPath(span<const std::experimental::string_view> path, Value value) {
   DCHECK_NE(path.begin(), path.end());  // Can't be empty path.
 
   // Walk/construct intermediate dictionaries. The last element requires
   // special handling so skip it in this loop.
   Value* cur = this;
-  const std::string_view* cur_path = path.begin();
+  const std::experimental::string_view* cur_path = path.begin();
   for (; (cur_path + 1) < path.end(); ++cur_path) {
     if (!cur->is_dict())
       return nullptr;
 
     // Use lower_bound to avoid doing the search twice for missing keys.
-    const std::string_view path_component = *cur_path;
+    const std::experimental::string_view path_component = *cur_path;
     auto found = cur->dict_.lower_bound(path_component);
     if (found == cur->dict_.end() || found->first != path_component) {
       // No key found, insert one.
@@ -379,12 +379,12 @@ Value* Value::SetPath(span<const std::st
   return cur->SetKey(*cur_path, std::move(value));
 }
 
-bool Value::RemovePath(std::initializer_list<std::string_view> path) {
+bool Value::RemovePath(std::initializer_list<std::experimental::string_view> path) {
   DCHECK_GE(path.size(), 2u) << "Use RemoveKey() for a path of length 1.";
   return RemovePath(make_span(path.begin(), path.size()));
 }
 
-bool Value::RemovePath(span<const std::string_view> path) {
+bool Value::RemovePath(span<const std::experimental::string_view> path) {
   if (!is_dict() || path.empty())
     return false;
 
@@ -462,7 +462,7 @@ bool Value::GetAsString(const Value** ou
   return is_string();
 }
 
-bool Value::GetAsString(std::string_view* out_value) const {
+bool Value::GetAsString(std::experimental::string_view* out_value) const {
   if (out_value && is_string()) {
     *out_value = string_value_;
     return true;
@@ -665,7 +665,7 @@ DictionaryValue::DictionaryValue(const D
 DictionaryValue::DictionaryValue(DictStorage&& in_dict) noexcept
     : Value(std::move(in_dict)) {}
 
-bool DictionaryValue::HasKey(std::string_view key) const {
+bool DictionaryValue::HasKey(std::experimental::string_view key) const {
   DCHECK(IsStringUTF8(key));
   auto current_entry = dict_.find(key);
   DCHECK((current_entry == dict_.end()) || current_entry->second);
@@ -676,18 +676,18 @@ void DictionaryValue::Clear() {
   dict_.clear();
 }
 
-Value* DictionaryValue::Set(std::string_view path,
+Value* DictionaryValue::Set(std::experimental::string_view path,
                             std::unique_ptr<Value> in_value) {
   DCHECK(IsStringUTF8(path));
   DCHECK(in_value);
 
-  std::string_view current_path(path);
+  std::experimental::string_view current_path(path);
   Value* current_dictionary = this;
   for (size_t delimiter_position = current_path.find('.');
-       delimiter_position != std::string_view::npos;
+       delimiter_position != std::experimental::string_view::npos;
        delimiter_position = current_path.find('.')) {
     // Assume that we're indexing into a dictionary.
-    std::string_view key = current_path.substr(0, delimiter_position);
+    std::experimental::string_view key = current_path.substr(0, delimiter_position);
     Value* child_dictionary =
         current_dictionary->FindKeyOfType(key, Type::DICTIONARY);
     if (!child_dictionary) {
@@ -703,40 +703,40 @@ Value* DictionaryValue::Set(std::string_
       ->SetWithoutPathExpansion(current_path, std::move(in_value));
 }
 
-Value* DictionaryValue::SetBoolean(std::string_view path, bool in_value) {
+Value* DictionaryValue::SetBoolean(std::experimental::string_view path, bool in_value) {
   return Set(path, std::make_unique<Value>(in_value));
 }
 
-Value* DictionaryValue::SetInteger(std::string_view path, int in_value) {
+Value* DictionaryValue::SetInteger(std::experimental::string_view path, int in_value) {
   return Set(path, std::make_unique<Value>(in_value));
 }
 
-Value* DictionaryValue::SetString(std::string_view path,
-                                  std::string_view in_value) {
+Value* DictionaryValue::SetString(std::experimental::string_view path,
+                                  std::experimental::string_view in_value) {
   return Set(path, std::make_unique<Value>(in_value));
 }
 
-Value* DictionaryValue::SetString(std::string_view path,
+Value* DictionaryValue::SetString(std::experimental::string_view path,
                                   const std::u16string& in_value) {
   return Set(path, std::make_unique<Value>(in_value));
 }
 
 DictionaryValue* DictionaryValue::SetDictionary(
-    std::string_view path,
+    std::experimental::string_view path,
     std::unique_ptr<DictionaryValue> in_value) {
   return static_cast<DictionaryValue*>(Set(path, std::move(in_value)));
 }
 
-ListValue* DictionaryValue::SetList(std::string_view path,
+ListValue* DictionaryValue::SetList(std::experimental::string_view path,
                                     std::unique_ptr<ListValue> in_value) {
   return static_cast<ListValue*>(Set(path, std::move(in_value)));
 }
 
 Value* DictionaryValue::SetWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     std::unique_ptr<Value> in_value) {
   // NOTE: We can't use |insert_or_assign| here, as only |try_emplace| does
-  // an explicit conversion from std::string_view to std::string if necessary.
+  // an explicit conversion from std::experimental::string_view to std::string if necessary.
   auto result = dict_.try_emplace(key, std::move(in_value));
   if (!result.second) {
     // in_value is guaranteed to be still intact at this point.
@@ -745,10 +745,10 @@ Value* DictionaryValue::SetWithoutPathEx
   return result.first->second.get();
 }
 
-bool DictionaryValue::Get(std::string_view path,
+bool DictionaryValue::Get(std::experimental::string_view path,
                           const Value** out_value) const {
   DCHECK(IsStringUTF8(path));
-  std::string_view current_path(path);
+  std::experimental::string_view current_path(path);
   const DictionaryValue* current_dictionary = this;
   for (size_t delimiter_position = current_path.find('.');
        delimiter_position != std::string::npos;
@@ -766,12 +766,12 @@ bool DictionaryValue::Get(std::string_vi
   return current_dictionary->GetWithoutPathExpansion(current_path, out_value);
 }
 
-bool DictionaryValue::Get(std::string_view path, Value** out_value) {
+bool DictionaryValue::Get(std::experimental::string_view path, Value** out_value) {
   return static_cast<const DictionaryValue&>(*this).Get(
       path, const_cast<const Value**>(out_value));
 }
 
-bool DictionaryValue::GetBoolean(std::string_view path,
+bool DictionaryValue::GetBoolean(std::experimental::string_view path,
                                  bool* bool_value) const {
   const Value* value;
   if (!Get(path, &value))
@@ -780,7 +780,7 @@ bool DictionaryValue::GetBoolean(std::st
   return value->GetAsBoolean(bool_value);
 }
 
-bool DictionaryValue::GetInteger(std::string_view path, int* out_value) const {
+bool DictionaryValue::GetInteger(std::experimental::string_view path, int* out_value) const {
   const Value* value;
   if (!Get(path, &value))
     return false;
@@ -788,7 +788,7 @@ bool DictionaryValue::GetInteger(std::st
   return value->GetAsInteger(out_value);
 }
 
-bool DictionaryValue::GetString(std::string_view path,
+bool DictionaryValue::GetString(std::experimental::string_view path,
                                 std::string* out_value) const {
   const Value* value;
   if (!Get(path, &value))
@@ -797,7 +797,7 @@ bool DictionaryValue::GetString(std::str
   return value->GetAsString(out_value);
 }
 
-bool DictionaryValue::GetString(std::string_view path,
+bool DictionaryValue::GetString(std::experimental::string_view path,
                                 std::u16string* out_value) const {
   const Value* value;
   if (!Get(path, &value))
@@ -806,7 +806,7 @@ bool DictionaryValue::GetString(std::str
   return value->GetAsString(out_value);
 }
 
-bool DictionaryValue::GetStringASCII(std::string_view path,
+bool DictionaryValue::GetStringASCII(std::experimental::string_view path,
                                      std::string* out_value) const {
   std::string out;
   if (!GetString(path, &out))
@@ -821,7 +821,7 @@ bool DictionaryValue::GetStringASCII(std
   return true;
 }
 
-bool DictionaryValue::GetBinary(std::string_view path,
+bool DictionaryValue::GetBinary(std::experimental::string_view path,
                                 const Value** out_value) const {
   const Value* value;
   bool result = Get(path, &value);
@@ -834,12 +834,12 @@ bool DictionaryValue::GetBinary(std::str
   return true;
 }
 
-bool DictionaryValue::GetBinary(std::string_view path, Value** out_value) {
+bool DictionaryValue::GetBinary(std::experimental::string_view path, Value** out_value) {
   return static_cast<const DictionaryValue&>(*this).GetBinary(
       path, const_cast<const Value**>(out_value));
 }
 
-bool DictionaryValue::GetDictionary(std::string_view path,
+bool DictionaryValue::GetDictionary(std::experimental::string_view path,
                                     const DictionaryValue** out_value) const {
   const Value* value;
   bool result = Get(path, &value);
@@ -852,13 +852,13 @@ bool DictionaryValue::GetDictionary(std:
   return true;
 }
 
-bool DictionaryValue::GetDictionary(std::string_view path,
+bool DictionaryValue::GetDictionary(std::experimental::string_view path,
                                     DictionaryValue** out_value) {
   return static_cast<const DictionaryValue&>(*this).GetDictionary(
       path, const_cast<const DictionaryValue**>(out_value));
 }
 
-bool DictionaryValue::GetList(std::string_view path,
+bool DictionaryValue::GetList(std::experimental::string_view path,
                               const ListValue** out_value) const {
   const Value* value;
   bool result = Get(path, &value);
@@ -871,12 +871,12 @@ bool DictionaryValue::GetList(std::strin
   return true;
 }
 
-bool DictionaryValue::GetList(std::string_view path, ListValue** out_value) {
+bool DictionaryValue::GetList(std::experimental::string_view path, ListValue** out_value) {
   return static_cast<const DictionaryValue&>(*this).GetList(
       path, const_cast<const ListValue**>(out_value));
 }
 
-bool DictionaryValue::GetWithoutPathExpansion(std::string_view key,
+bool DictionaryValue::GetWithoutPathExpansion(std::experimental::string_view key,
                                               const Value** out_value) const {
   DCHECK(IsStringUTF8(key));
   auto entry_iterator = dict_.find(key);
@@ -888,13 +888,13 @@ bool DictionaryValue::GetWithoutPathExpa
   return true;
 }
 
-bool DictionaryValue::GetWithoutPathExpansion(std::string_view key,
+bool DictionaryValue::GetWithoutPathExpansion(std::experimental::string_view key,
                                               Value** out_value) {
   return static_cast<const DictionaryValue&>(*this).GetWithoutPathExpansion(
       key, const_cast<const Value**>(out_value));
 }
 
-bool DictionaryValue::GetBooleanWithoutPathExpansion(std::string_view key,
+bool DictionaryValue::GetBooleanWithoutPathExpansion(std::experimental::string_view key,
                                                      bool* out_value) const {
   const Value* value;
   if (!GetWithoutPathExpansion(key, &value))
@@ -903,7 +903,7 @@ bool DictionaryValue::GetBooleanWithoutP
   return value->GetAsBoolean(out_value);
 }
 
-bool DictionaryValue::GetIntegerWithoutPathExpansion(std::string_view key,
+bool DictionaryValue::GetIntegerWithoutPathExpansion(std::experimental::string_view key,
                                                      int* out_value) const {
   const Value* value;
   if (!GetWithoutPathExpansion(key, &value))
@@ -913,7 +913,7 @@ bool DictionaryValue::GetIntegerWithoutP
 }
 
 bool DictionaryValue::GetStringWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     std::string* out_value) const {
   const Value* value;
   if (!GetWithoutPathExpansion(key, &value))
@@ -923,7 +923,7 @@ bool DictionaryValue::GetStringWithoutPa
 }
 
 bool DictionaryValue::GetStringWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     std::u16string* out_value) const {
   const Value* value;
   if (!GetWithoutPathExpansion(key, &value))
@@ -933,7 +933,7 @@ bool DictionaryValue::GetStringWithoutPa
 }
 
 bool DictionaryValue::GetDictionaryWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     const DictionaryValue** out_value) const {
   const Value* value;
   bool result = GetWithoutPathExpansion(key, &value);
@@ -947,7 +947,7 @@ bool DictionaryValue::GetDictionaryWitho
 }
 
 bool DictionaryValue::GetDictionaryWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     DictionaryValue** out_value) {
   const DictionaryValue& const_this =
       static_cast<const DictionaryValue&>(*this);
@@ -956,7 +956,7 @@ bool DictionaryValue::GetDictionaryWitho
 }
 
 bool DictionaryValue::GetListWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     const ListValue** out_value) const {
   const Value* value;
   bool result = GetWithoutPathExpansion(key, &value);
@@ -969,19 +969,19 @@ bool DictionaryValue::GetListWithoutPath
   return true;
 }
 
-bool DictionaryValue::GetListWithoutPathExpansion(std::string_view key,
+bool DictionaryValue::GetListWithoutPathExpansion(std::experimental::string_view key,
                                                   ListValue** out_value) {
   return static_cast<const DictionaryValue&>(*this).GetListWithoutPathExpansion(
       key, const_cast<const ListValue**>(out_value));
 }
 
-bool DictionaryValue::Remove(std::string_view path,
+bool DictionaryValue::Remove(std::experimental::string_view path,
                              std::unique_ptr<Value>* out_value) {
   DCHECK(IsStringUTF8(path));
-  std::string_view current_path(path);
+  std::experimental::string_view current_path(path);
   DictionaryValue* current_dictionary = this;
   size_t delimiter_position = current_path.rfind('.');
-  if (delimiter_position != std::string_view::npos) {
+  if (delimiter_position != std::experimental::string_view::npos) {
     if (!GetDictionary(current_path.substr(0, delimiter_position),
                        &current_dictionary))
       return false;
@@ -993,7 +993,7 @@ bool DictionaryValue::Remove(std::string
 }
 
 bool DictionaryValue::RemoveWithoutPathExpansion(
-    std::string_view key,
+    std::experimental::string_view key,
     std::unique_ptr<Value>* out_value) {
   DCHECK(IsStringUTF8(key));
   auto entry_iterator = dict_.find(key);
@@ -1006,7 +1006,7 @@ bool DictionaryValue::RemoveWithoutPathE
   return true;
 }
 
-bool DictionaryValue::RemovePath(std::string_view path,
+bool DictionaryValue::RemovePath(std::experimental::string_view path,
                                  std::unique_ptr<Value>* out_value) {
   bool result = false;
   size_t delimiter_position = path.find('.');
@@ -1014,7 +1014,7 @@ bool DictionaryValue::RemovePath(std::st
   if (delimiter_position == std::string::npos)
     return RemoveWithoutPathExpansion(path, out_value);
 
-  std::string_view subdict_path = path.substr(0, delimiter_position);
+  std::experimental::string_view subdict_path = path.substr(0, delimiter_position);
   DictionaryValue* subdict = nullptr;
   if (!GetDictionary(subdict_path, &subdict))
     return false;
@@ -1234,7 +1234,7 @@ void ListValue::AppendInteger(int in_val
   list_.emplace_back(in_value);
 }
 
-void ListValue::AppendString(std::string_view in_value) {
+void ListValue::AppendString(std::experimental::string_view in_value) {
   list_.emplace_back(in_value);
 }
 
Index: beta/tools/gn/src/base/values.h
===================================================================
--- beta.orig/tools/gn/src/base/values.h
+++ beta/tools/gn/src/base/values.h
@@ -27,7 +27,7 @@
 #include <map>
 #include <memory>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <utility>
 #include <vector>
 
@@ -116,14 +116,14 @@ class Value {
   explicit Value(int in_int);
 
   // Value(const char*) and Value(const char16_t*) are required despite
-  // Value(std::string_view) and Value(std::u16string_view) because otherwise
+  // Value(std::experimental::string_view) and Value(std::experimental::u16string_view) because otherwise
   // the compiler will choose the Value(bool) constructor for these arguments.
   // Value(std::string&&) allow for efficient move construction.
   explicit Value(const char* in_string);
-  explicit Value(std::string_view in_string);
+  explicit Value(std::experimental::string_view in_string);
   explicit Value(std::string&& in_string) noexcept;
   explicit Value(const char16_t* in_string16);
-  explicit Value(std::u16string_view in_string16);
+  explicit Value(std::experimental::u16string_view in_string16);
 
   explicit Value(const BlobStorage& in_blob);
   explicit Value(BlobStorage&& in_blob) noexcept;
@@ -170,8 +170,8 @@ class Value {
   //
   // Example:
   //   auto* found = FindKey("foo");
-  Value* FindKey(std::string_view key);
-  const Value* FindKey(std::string_view key) const;
+  Value* FindKey(std::experimental::string_view key);
+  const Value* FindKey(std::experimental::string_view key) const;
 
   // |FindKeyOfType| is similar to |FindKey|, but it also requires the found
   // value to have type |type|. If no type is found, or the found value is of a
@@ -182,8 +182,8 @@ class Value {
   //
   // Example:
   //   auto* found = FindKey("foo", Type::INTEGER);
-  Value* FindKeyOfType(std::string_view key, Type type);
-  const Value* FindKeyOfType(std::string_view key, Type type) const;
+  Value* FindKeyOfType(std::experimental::string_view key, Type type);
+  const Value* FindKeyOfType(std::experimental::string_view key, Type type) const;
 
   // |SetKey| looks up |key| in the underlying dictionary and sets the mapped
   // value to |value|. If |key| could not be found, a new element is inserted.
@@ -192,7 +192,7 @@ class Value {
   //
   // Example:
   //   SetKey("foo", std::move(myvalue));
-  Value* SetKey(std::string_view key, Value value);
+  Value* SetKey(std::experimental::string_view key, Value value);
   // This overload results in a performance improvement for std::string&&.
   Value* SetKey(std::string&& key, Value value);
   // This overload is necessary to avoid ambiguity for const char* arguments.
@@ -206,7 +206,7 @@ class Value {
   //
   // Example:
   //   bool success = RemoveKey("foo");
-  bool RemoveKey(std::string_view key);
+  bool RemoveKey(std::experimental::string_view key);
 
   // Searches a hierarchy of dictionary values for a given value. If a path
   // of dictionaries exist, returns the item at that path. If any of the path
@@ -222,26 +222,26 @@ class Value {
   // Example:
   //   auto* found = FindPath({"foo", "bar"});
   //
-  //   std::vector<std::string_view> components = ...
+  //   std::vector<std::experimental::string_view> components = ...
   //   auto* found = FindPath(components);
   //
   // Note: If there is only one component in the path, use FindKey() instead.
-  Value* FindPath(std::initializer_list<std::string_view> path);
-  Value* FindPath(span<const std::string_view> path);
-  const Value* FindPath(std::initializer_list<std::string_view> path) const;
-  const Value* FindPath(span<const std::string_view> path) const;
+  Value* FindPath(std::initializer_list<std::experimental::string_view> path);
+  Value* FindPath(span<const std::experimental::string_view> path);
+  const Value* FindPath(std::initializer_list<std::experimental::string_view> path) const;
+  const Value* FindPath(span<const std::experimental::string_view> path) const;
 
   // Like FindPath() but will only return the value if the leaf Value type
   // matches the given type. Will return nullptr otherwise.
   //
   // Note: If there is only one component in the path, use FindKeyOfType()
   // instead.
-  Value* FindPathOfType(std::initializer_list<std::string_view> path,
+  Value* FindPathOfType(std::initializer_list<std::experimental::string_view> path,
                         Type type);
-  Value* FindPathOfType(span<const std::string_view> path, Type type);
-  const Value* FindPathOfType(std::initializer_list<std::string_view> path,
+  Value* FindPathOfType(span<const std::experimental::string_view> path, Type type);
+  const Value* FindPathOfType(std::initializer_list<std::experimental::string_view> path,
                               Type type) const;
-  const Value* FindPathOfType(span<const std::string_view> path,
+  const Value* FindPathOfType(span<const std::experimental::string_view> path,
                               Type type) const;
 
   // Sets the given path, expanding and creating dictionary keys as necessary.
@@ -256,12 +256,12 @@ class Value {
   // Example:
   //   value.SetPath({"foo", "bar"}, std::move(myvalue));
   //
-  //   std::vector<std::string_view> components = ...
+  //   std::vector<std::experimental::string_view> components = ...
   //   value.SetPath(components, std::move(myvalue));
   //
   // Note: If there is only one component in the path, use SetKey() instead.
-  Value* SetPath(std::initializer_list<std::string_view> path, Value value);
-  Value* SetPath(span<const std::string_view> path, Value value);
+  Value* SetPath(std::initializer_list<std::experimental::string_view> path, Value value);
+  Value* SetPath(span<const std::experimental::string_view> path, Value value);
 
   // Tries to remove a Value at the given path.
   //
@@ -273,12 +273,12 @@ class Value {
   // Example:
   //   bool success = value.RemovePath({"foo", "bar"});
   //
-  //   std::vector<std::string_view> components = ...
+  //   std::vector<std::experimental::string_view> components = ...
   //   bool success = value.RemovePath(components);
   //
   // Note: If there is only one component in the path, use RemoveKey() instead.
-  bool RemovePath(std::initializer_list<std::string_view> path);
-  bool RemovePath(span<const std::string_view> path);
+  bool RemovePath(std::initializer_list<std::experimental::string_view> path);
+  bool RemovePath(span<const std::experimental::string_view> path);
 
   using dict_iterator_proxy = detail::dict_iterator_proxy;
   using const_dict_iterator_proxy = detail::const_dict_iterator_proxy;
@@ -308,7 +308,7 @@ class Value {
   bool GetAsString(std::string* out_value) const;
   bool GetAsString(std::u16string* out_value) const;
   bool GetAsString(const Value** out_value) const;
-  bool GetAsString(std::string_view* out_value) const;
+  bool GetAsString(std::experimental::string_view* out_value) const;
   // ListValue::From is the equivalent for std::unique_ptr conversions.
   // DEPRECATED, use GetList() instead.
   bool GetAsList(ListValue** out_value);
@@ -385,7 +385,7 @@ class DictionaryValue : public Value {
 
   // Returns true if the current dictionary has a value for the given key.
   // DEPRECATED, use Value::FindKey(key) instead.
-  bool HasKey(std::string_view key) const;
+  bool HasKey(std::experimental::string_view key) const;
 
   // Returns the number of Values in this dictionary.
   size_t size() const { return dict_.size(); }
@@ -405,29 +405,29 @@ class DictionaryValue : public Value {
   // to the path in that location. |in_value| must be non-null.
   // Returns a pointer to the inserted value.
   // DEPRECATED, use Value::SetPath(path, value) instead.
-  Value* Set(std::string_view path, std::unique_ptr<Value> in_value);
+  Value* Set(std::experimental::string_view path, std::unique_ptr<Value> in_value);
 
   // Convenience forms of Set().  These methods will replace any existing
   // value at that path, even if it has a different type.
   // DEPRECATED, use Value::SetPath(path, Value(bool)) instead.
-  Value* SetBoolean(std::string_view path, bool in_value);
+  Value* SetBoolean(std::experimental::string_view path, bool in_value);
   // DEPRECATED, use Value::SetPath(path, Value(int)) instead.
-  Value* SetInteger(std::string_view path, int in_value);
-  // DEPRECATED, use Value::SetPath(path, Value(std::string_view)) instead.
-  Value* SetString(std::string_view path, std::string_view in_value);
+  Value* SetInteger(std::experimental::string_view path, int in_value);
+  // DEPRECATED, use Value::SetPath(path, Value(std::experimental::string_view)) instead.
+  Value* SetString(std::experimental::string_view path, std::experimental::string_view in_value);
   // DEPRECATED, use Value::SetPath(path, Value(const string& 16)) instead.
-  Value* SetString(std::string_view path, const std::u16string& in_value);
+  Value* SetString(std::experimental::string_view path, const std::u16string& in_value);
   // DEPRECATED, use Value::SetPath(path, Value(Type::DICTIONARY)) instead.
-  DictionaryValue* SetDictionary(std::string_view path,
+  DictionaryValue* SetDictionary(std::experimental::string_view path,
                                  std::unique_ptr<DictionaryValue> in_value);
   // DEPRECATED, use Value::SetPath(path, Value(Type::LIST)) instead.
-  ListValue* SetList(std::string_view path,
+  ListValue* SetList(std::experimental::string_view path,
                      std::unique_ptr<ListValue> in_value);
 
   // Like Set(), but without special treatment of '.'.  This allows e.g. URLs to
   // be used as paths.
   // DEPRECATED, use Value::SetKey(key, value) instead.
-  Value* SetWithoutPathExpansion(std::string_view key,
+  Value* SetWithoutPathExpansion(std::experimental::string_view key,
                                  std::unique_ptr<Value> in_value);
 
   // Gets the Value associated with the given path starting from this object.
@@ -439,69 +439,69 @@ class DictionaryValue : public Value {
   // Note that the dictionary always owns the value that's returned.
   // |out_value| is optional and will only be set if non-NULL.
   // DEPRECATED, use Value::FindPath(path) instead.
-  bool Get(std::string_view path, const Value** out_value) const;
+  bool Get(std::experimental::string_view path, const Value** out_value) const;
   // DEPRECATED, use Value::FindPath(path) instead.
-  bool Get(std::string_view path, Value** out_value);
+  bool Get(std::experimental::string_view path, Value** out_value);
 
   // These are convenience forms of Get().  The value will be retrieved
   // and the return value will be true if the path is valid and the value at
   // the end of the path can be returned in the form specified.
   // |out_value| is optional and will only be set if non-NULL.
   // DEPRECATED, use Value::FindPath(path) and Value::GetBool() instead.
-  bool GetBoolean(std::string_view path, bool* out_value) const;
+  bool GetBoolean(std::experimental::string_view path, bool* out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetInt() instead.
-  bool GetInteger(std::string_view path, int* out_value) const;
+  bool GetInteger(std::experimental::string_view path, int* out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetString() instead.
-  bool GetString(std::string_view path, std::string* out_value) const;
+  bool GetString(std::experimental::string_view path, std::string* out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetString() instead.
-  bool GetString(std::string_view path, std::u16string* out_value) const;
+  bool GetString(std::experimental::string_view path, std::u16string* out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetString() instead.
-  bool GetStringASCII(std::string_view path, std::string* out_value) const;
+  bool GetStringASCII(std::experimental::string_view path, std::string* out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetBlob() instead.
-  bool GetBinary(std::string_view path, const Value** out_value) const;
+  bool GetBinary(std::experimental::string_view path, const Value** out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetBlob() instead.
-  bool GetBinary(std::string_view path, Value** out_value);
+  bool GetBinary(std::experimental::string_view path, Value** out_value);
   // DEPRECATED, use Value::FindPath(path) and Value's Dictionary API instead.
-  bool GetDictionary(std::string_view path,
+  bool GetDictionary(std::experimental::string_view path,
                      const DictionaryValue** out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value's Dictionary API instead.
-  bool GetDictionary(std::string_view path, DictionaryValue** out_value);
+  bool GetDictionary(std::experimental::string_view path, DictionaryValue** out_value);
   // DEPRECATED, use Value::FindPath(path) and Value::GetList() instead.
-  bool GetList(std::string_view path, const ListValue** out_value) const;
+  bool GetList(std::experimental::string_view path, const ListValue** out_value) const;
   // DEPRECATED, use Value::FindPath(path) and Value::GetList() instead.
-  bool GetList(std::string_view path, ListValue** out_value);
+  bool GetList(std::experimental::string_view path, ListValue** out_value);
 
   // Like Get(), but without special treatment of '.'.  This allows e.g. URLs to
   // be used as paths.
   // DEPRECATED, use Value::FindKey(key) instead.
-  bool GetWithoutPathExpansion(std::string_view key,
+  bool GetWithoutPathExpansion(std::experimental::string_view key,
                                const Value** out_value) const;
   // DEPRECATED, use Value::FindKey(key) instead.
-  bool GetWithoutPathExpansion(std::string_view key, Value** out_value);
+  bool GetWithoutPathExpansion(std::experimental::string_view key, Value** out_value);
   // DEPRECATED, use Value::FindKey(key) and Value::GetBool() instead.
-  bool GetBooleanWithoutPathExpansion(std::string_view key,
+  bool GetBooleanWithoutPathExpansion(std::experimental::string_view key,
                                       bool* out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value::GetInt() instead.
-  bool GetIntegerWithoutPathExpansion(std::string_view key,
+  bool GetIntegerWithoutPathExpansion(std::experimental::string_view key,
                                       int* out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value::GetString() instead.
-  bool GetStringWithoutPathExpansion(std::string_view key,
+  bool GetStringWithoutPathExpansion(std::experimental::string_view key,
                                      std::string* out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value::GetString() instead.
-  bool GetStringWithoutPathExpansion(std::string_view key,
+  bool GetStringWithoutPathExpansion(std::experimental::string_view key,
                                      std::u16string* out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value's Dictionary API instead.
   bool GetDictionaryWithoutPathExpansion(
-      std::string_view key,
+      std::experimental::string_view key,
       const DictionaryValue** out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value's Dictionary API instead.
-  bool GetDictionaryWithoutPathExpansion(std::string_view key,
+  bool GetDictionaryWithoutPathExpansion(std::experimental::string_view key,
                                          DictionaryValue** out_value);
   // DEPRECATED, use Value::FindKey(key) and Value::GetList() instead.
-  bool GetListWithoutPathExpansion(std::string_view key,
+  bool GetListWithoutPathExpansion(std::experimental::string_view key,
                                    const ListValue** out_value) const;
   // DEPRECATED, use Value::FindKey(key) and Value::GetList() instead.
-  bool GetListWithoutPathExpansion(std::string_view key, ListValue** out_value);
+  bool GetListWithoutPathExpansion(std::experimental::string_view key, ListValue** out_value);
 
   // Removes the Value with the specified path from this dictionary (or one
   // of its child dictionaries, if the path is more than just a local key).
@@ -510,18 +510,18 @@ class DictionaryValue : public Value {
   // This method returns true if |path| is a valid path; otherwise it will
   // return false and the DictionaryValue object will be unchanged.
   // DEPRECATED, use Value::RemovePath(path) instead.
-  bool Remove(std::string_view path, std::unique_ptr<Value>* out_value);
+  bool Remove(std::experimental::string_view path, std::unique_ptr<Value>* out_value);
 
   // Like Remove(), but without special treatment of '.'.  This allows e.g. URLs
   // to be used as paths.
   // DEPRECATED, use Value::RemoveKey(key) instead.
-  bool RemoveWithoutPathExpansion(std::string_view key,
+  bool RemoveWithoutPathExpansion(std::experimental::string_view key,
                                   std::unique_ptr<Value>* out_value);
 
   // Removes a path, clearing out all dictionaries on |path| that remain empty
   // after removing the value at |path|.
   // DEPRECATED, use Value::RemovePath(path) instead.
-  bool RemovePath(std::string_view path, std::unique_ptr<Value>* out_value);
+  bool RemovePath(std::experimental::string_view path, std::unique_ptr<Value>* out_value);
 
   using Value::RemovePath;  // DictionaryValue::RemovePath shadows otherwise.
 
@@ -670,7 +670,7 @@ class ListValue : public Value {
   // DEPRECATED, use GetList()::emplace_back() instead.
   void AppendBoolean(bool in_value);
   void AppendInteger(int in_value);
-  void AppendString(std::string_view in_value);
+  void AppendString(std::experimental::string_view in_value);
   void AppendString(const std::u16string& in_value);
   // DEPRECATED, use GetList()::emplace_back() in a loop instead.
   void AppendStrings(const std::vector<std::string>& in_values);
Index: beta/tools/gn/src/gn/args.cc
===================================================================
--- beta.orig/tools/gn/src/gn/args.cc
+++ beta/tools/gn/src/gn/args.cc
@@ -108,8 +108,8 @@ Args::~Args() = default;
 void Args::AddArgOverride(const char* name, const Value& value) {
   std::lock_guard<std::mutex> lock(lock_);
 
-  overrides_[std::string_view(name)] = value;
-  all_overrides_[std::string_view(name)] = value;
+  overrides_[std::experimental::string_view(name)] = value;
+  all_overrides_[std::experimental::string_view(name)] = value;
 }
 
 void Args::AddArgOverrides(const Scope::KeyValueMap& overrides) {
@@ -131,7 +131,7 @@ const Value* Args::GetArgOverride(const
   std::lock_guard<std::mutex> lock(lock_);
 
   Scope::KeyValueMap::const_iterator found =
-      all_overrides_.find(std::string_view(name));
+      all_overrides_.find(std::experimental::string_view(name));
   if (found == all_overrides_.end())
     return nullptr;
   return &found->second;
@@ -240,7 +240,7 @@ bool Args::VerifyAllOverridesUsed(Err* e
 
   // Some assignments in args.gn had no effect.  Show an error for the first
   // unused assignment.
-  std::string_view name = unused_overrides.begin()->first;
+  std::experimental::string_view name = unused_overrides.begin()->first;
   const Value& value = unused_overrides.begin()->second;
 
   std::string err_help(
@@ -250,12 +250,12 @@ bool Args::VerifyAllOverridesUsed(Err* e
       "To view all possible args, run \"gn args --list <out_dir>\"");
 
   // Use all declare_args for a spelling suggestion.
-  std::vector<std::string_view> candidates;
+  std::vector<std::experimental::string_view> candidates;
   for (const auto& map_pair : declared_arguments_per_toolchain_) {
     for (const auto& declared_arg : map_pair.second)
       candidates.push_back(declared_arg.first);
   }
-  std::string_view suggestion = SpellcheckString(name, candidates);
+  std::experimental::string_view suggestion = SpellcheckString(name, candidates);
   if (!suggestion.empty())
     err_help = "Did you mean \"" + suggestion + "\"?\n\n" + err_help;
 
Index: beta/tools/gn/src/gn/args.h
===================================================================
--- beta.orig/tools/gn/src/gn/args.h
+++ beta/tools/gn/src/gn/args.h
@@ -37,7 +37,7 @@ class Args {
     bool has_override;     // True indicates override_value is valid.
     Value override_value;  // From .gn or the current build's "gn args".
   };
-  using ValueWithOverrideMap = std::map<std::string_view, ValueWithOverride>;
+  using ValueWithOverrideMap = std::map<std::experimental::string_view, ValueWithOverride>;
 
   Args();
   Args(const Args& other);
Index: beta/tools/gn/src/gn/bundle_data.cc
===================================================================
--- beta.orig/tools/gn/src/gn/bundle_data.cc
+++ beta/tools/gn/src/gn/bundle_data.cc
@@ -16,14 +16,14 @@
 namespace {
 
 // Return directory of |path| without the trailing directory separator.
-std::string_view FindDirNoTrailingSeparator(std::string_view path) {
-  std::string_view::size_type pos = path.find_last_of("/\\");
-  if (pos == std::string_view::npos)
-    return std::string_view();
-  return std::string_view(path.data(), pos);
+std::experimental::string_view FindDirNoTrailingSeparator(std::experimental::string_view path) {
+  std::experimental::string_view::size_type pos = path.find_last_of("/\\");
+  if (pos == std::experimental::string_view::npos)
+    return std::experimental::string_view();
+  return std::experimental::string_view(path.data(), pos);
 }
 
-bool IsSourceFileFromAssetsCatalog(std::string_view source,
+bool IsSourceFileFromAssetsCatalog(std::experimental::string_view source,
                                    SourceFile* asset_catalog) {
   // Check whether |source| matches one of the following pattern:
   //    .*\.xcassets/Contents.json
@@ -33,7 +33,7 @@ bool IsSourceFileFromAssetsCatalog(std::
   //    .*\.xcassets/[^/]*\.colorset/[^/]*
   //    .*\.xcassets/[^/]*\.dataset/[^/]*
   bool is_file_from_asset_catalog = false;
-  std::string_view dir = FindDirNoTrailingSeparator(source);
+  std::experimental::string_view dir = FindDirNoTrailingSeparator(source);
   if (base::EndsWith(source, "/Contents.json", base::CompareCase::SENSITIVE) &&
       base::EndsWith(dir, ".xcassets", base::CompareCase::SENSITIVE)) {
     is_file_from_asset_catalog = true;
Index: beta/tools/gn/src/gn/c_include_iterator.cc
===================================================================
--- beta.orig/tools/gn/src/gn/c_include_iterator.cc
+++ beta/tools/gn/src/gn/c_include_iterator.cc
@@ -23,7 +23,7 @@ enum IncludeType {
 // Returns a new string piece referencing the same buffer as the argument, but
 // with leading space trimmed. This only checks for space and tab characters
 // since we're dealing with lines in C source files.
-std::string_view TrimLeadingWhitespace(const std::string_view& str) {
+std::experimental::string_view TrimLeadingWhitespace(const std::experimental::string_view& str) {
   size_t new_begin = 0;
   while (new_begin < str.size() &&
          (str[new_begin] == ' ' || str[new_begin] == '\t'))
@@ -42,7 +42,7 @@ std::string_view TrimLeadingWhitespace(c
 //
 // We assume the line has leading whitespace trimmed. We also assume that empty
 // lines have already been filtered out.
-bool ShouldCountTowardNonIncludeLines(const std::string_view& line) {
+bool ShouldCountTowardNonIncludeLines(const std::experimental::string_view& line) {
   if (base::StartsWith(line, "//", base::CompareCase::SENSITIVE))
     return false;  // Don't count comments.
   if (base::StartsWith(line, "/*", base::CompareCase::SENSITIVE) ||
@@ -61,15 +61,15 @@ bool ShouldCountTowardNonIncludeLines(co
 //
 // The 1-based character number on the line that the include was found at
 // will be filled into *begin_char.
-IncludeType ExtractInclude(const std::string_view& line,
-                           std::string_view* path,
+IncludeType ExtractInclude(const std::experimental::string_view& line,
+                           std::experimental::string_view* path,
                            int* begin_char) {
   static const char kInclude[] = "include";
   static const size_t kIncludeLen = std::size(kInclude) - 1;  // No null.
   static const char kImport[] = "import";
   static const size_t kImportLen = std::size(kImport) - 1;  // No null.
 
-  std::string_view trimmed = TrimLeadingWhitespace(line);
+  std::experimental::string_view trimmed = TrimLeadingWhitespace(line);
   if (trimmed.empty())
     return INCLUDE_NONE;
 
@@ -78,11 +78,11 @@ IncludeType ExtractInclude(const std::st
 
   trimmed = TrimLeadingWhitespace(trimmed.substr(1));
 
-  std::string_view contents;
-  if (base::StartsWith(trimmed, std::string_view(kInclude, kIncludeLen),
+  std::experimental::string_view contents;
+  if (base::StartsWith(trimmed, std::experimental::string_view(kInclude, kIncludeLen),
                        base::CompareCase::SENSITIVE))
     contents = TrimLeadingWhitespace(trimmed.substr(kIncludeLen));
-  else if (base::StartsWith(trimmed, std::string_view(kImport, kImportLen),
+  else if (base::StartsWith(trimmed, std::experimental::string_view(kImport, kImportLen),
                             base::CompareCase::SENSITIVE))
     contents = TrimLeadingWhitespace(trimmed.substr(kImportLen));
 
@@ -103,7 +103,7 @@ IncludeType ExtractInclude(const std::st
 
   // Count everything to next "/> as the contents.
   size_t terminator_index = contents.find(terminating_char, 1);
-  if (terminator_index == std::string_view::npos)
+  if (terminator_index == std::experimental::string_view::npos)
     return INCLUDE_NONE;
 
   *path = contents.substr(1, terminator_index - 1);
@@ -113,8 +113,8 @@ IncludeType ExtractInclude(const std::st
 }
 
 // Returns true if this line has a "nogncheck" comment associated with it.
-bool HasNoCheckAnnotation(const std::string_view& line) {
-  return line.find("nogncheck") != std::string_view::npos;
+bool HasNoCheckAnnotation(const std::experimental::string_view& line) {
+  return line.find("nogncheck") != std::experimental::string_view::npos;
 }
 
 }  // namespace
@@ -128,11 +128,11 @@ CIncludeIterator::~CIncludeIterator() =
 
 bool CIncludeIterator::GetNextIncludeString(
     IncludeStringWithLocation* include) {
-  std::string_view line;
+  std::experimental::string_view line;
   int cur_line_number = 0;
   while (lines_since_last_include_ <= kMaxNonIncludeLines &&
          GetNextLine(&line, &cur_line_number)) {
-    std::string_view include_contents;
+    std::experimental::string_view include_contents;
     int begin_char;
     IncludeType type = ExtractInclude(line, &include_contents, &begin_char);
     if (HasNoCheckAnnotation(line))
@@ -157,7 +157,7 @@ bool CIncludeIterator::GetNextIncludeStr
   return false;
 }
 
-bool CIncludeIterator::GetNextLine(std::string_view* line, int* line_number) {
+bool CIncludeIterator::GetNextLine(std::experimental::string_view* line, int* line_number) {
   if (offset_ == file_.size())
     return false;
 
Index: beta/tools/gn/src/gn/c_include_iterator.h
===================================================================
--- beta.orig/tools/gn/src/gn/c_include_iterator.h
+++ beta/tools/gn/src/gn/c_include_iterator.h
@@ -7,7 +7,7 @@
 
 #include <stddef.h>
 
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/macros.h"
 #include "gn/location.h"
@@ -15,7 +15,7 @@
 class InputFile;
 
 struct IncludeStringWithLocation {
-  std::string_view contents;
+  std::experimental::string_view contents;
   LocationRange location;
   bool system_style_include = false;
 };
@@ -39,12 +39,12 @@ class CIncludeIterator {
  private:
   // Returns false on EOF, otherwise fills in the given line and the one-based
   // line number into *line_number;
-  bool GetNextLine(std::string_view* line, int* line_number);
+  bool GetNextLine(std::experimental::string_view* line, int* line_number);
 
   const InputFile* input_file_;
 
   // This just points into input_file_.contents() for convenience.
-  std::string_view file_;
+  std::experimental::string_view file_;
 
   // 0-based offset into the file.
   size_t offset_ = 0;
Index: beta/tools/gn/src/gn/command_args.cc
===================================================================
--- beta.orig/tools/gn/src/gn/command_args.cc
+++ beta/tools/gn/src/gn/command_args.cc
@@ -40,7 +40,7 @@ const char kSwitchShort[] = "short";
 const char kSwitchOverridesOnly[] = "overrides-only";
 const char kSwitchJson[] = "json";
 
-bool DoesLineBeginWithComment(const std::string_view& line) {
+bool DoesLineBeginWithComment(const std::experimental::string_view& line) {
   // Skip whitespace.
   size_t i = 0;
   while (i < line.size() && base::IsAsciiWhitespace(line[i]))
@@ -67,7 +67,7 @@ size_t BackUpToLineBegin(const std::stri
 
 // Assumes DoesLineBeginWithComment(), this strips the # character from the
 // beginning and normalizes preceding whitespace.
-std::string StripHashFromLine(const std::string_view& line, bool pad) {
+std::string StripHashFromLine(const std::experimental::string_view& line, bool pad) {
   // Replace the # sign and everything before it with 3 spaces, so that a
   // normal comment that has a space after the # will be indented 4 spaces
   // (which makes our formatting come out nicely). If the comment is indented
@@ -104,7 +104,7 @@ void GetContextForValue(const Value& val
     line_off -= 2;  // Back up to end of previous line.
     size_t previous_line_offset = BackUpToLineBegin(data, line_off);
 
-    std::string_view line(&data[previous_line_offset],
+    std::experimental::string_view line(&data[previous_line_offset],
                           line_off - previous_line_offset + 1);
     if (!DoesLineBeginWithComment(line))
       break;
@@ -120,7 +120,7 @@ void GetContextForValue(const Value& val
 // is a bit different.
 //
 // The default value also contains the docstring.
-void PrintDefaultValueInfo(std::string_view name, const Value& value) {
+void PrintDefaultValueInfo(std::experimental::string_view name, const Value& value) {
   OutputString(value.ToString(true) + "\n");
   if (value.origin()) {
     int line_no;
@@ -137,7 +137,7 @@ void PrintDefaultValueInfo(std::string_v
 }
 
 // Override value is null if there is no override.
-void PrintArgHelp(const std::string_view& name,
+void PrintArgHelp(const std::experimental::string_view& name,
                   const Args::ValueWithOverride& val) {
   OutputString(std::string(name), DECORATION_YELLOW);
   OutputString("\n");
@@ -163,7 +163,7 @@ void PrintArgHelp(const std::string_view
 }
 
 void BuildArgJson(base::Value& dict,
-                  const std::string_view& name,
+                  const std::experimental::string_view& name,
                   const Args::ValueWithOverride& arg,
                   bool short_only) {
   assert(dict.is_dict());
Index: beta/tools/gn/src/gn/command_clean.cc
===================================================================
--- beta.orig/tools/gn/src/gn/command_clean.cc
+++ beta/tools/gn/src/gn/command_clean.cc
@@ -27,7 +27,7 @@ std::string ExtractGNBuildCommands(const
   if (!base::ReadFileToString(build_ninja_file, &file_contents))
     return std::string();
 
-  std::vector<std::string_view> lines = base::SplitStringPiece(
+  std::vector<std::experimental::string_view> lines = base::SplitStringPiece(
       file_contents, "\n", base::KEEP_WHITESPACE, base::SPLIT_WANT_ALL);
 
   std::string result;
Index: beta/tools/gn/src/gn/command_format.cc
===================================================================
--- beta.orig/tools/gn/src/gn/command_format.cc
+++ beta/tools/gn/src/gn/command_format.cc
@@ -128,7 +128,7 @@ class Printer {
   };
 
   // Add to output.
-  void Print(std::string_view str);
+  void Print(std::experimental::string_view str);
 
   // Add the current margin (as spaces) to the output.
   void PrintMargin();
@@ -242,7 +242,7 @@ class Printer {
   std::vector<IndentState> stack_;
 
   // Gives the precedence for operators in a BinaryOpNode.
-  std::map<std::string_view, Precedence> precedence_;
+  std::map<std::experimental::string_view, Precedence> precedence_;
 
   DISALLOW_COPY_AND_ASSIGN(Printer);
 };
@@ -268,7 +268,7 @@ Printer::Printer() : penalty_depth_(0) {
 
 Printer::~Printer() = default;
 
-void Printer::Print(std::string_view str) {
+void Printer::Print(std::experimental::string_view str) {
   output_.append(str);
 }
 
@@ -391,7 +391,7 @@ void Printer::SortIfSourcesOrDeps(const
   if ((binop->op().value() == "=" || binop->op().value() == "+=" ||
        binop->op().value() == "-=") &&
       ident && list) {
-    const std::string_view lhs = ident->value().value();
+    const std::experimental::string_view lhs = ident->value().value();
     if (base::EndsWith(lhs, "sources", base::CompareCase::SENSITIVE) ||
         lhs == "public")
       const_cast<ListNode*>(list)->SortAsStringsList();
@@ -434,14 +434,14 @@ void Printer::SortImports(std::vector<st
                     const std::unique_ptr<PARSENODE>& b) const {
       const auto& a_args = a->AsFunctionCall()->args()->contents();
       const auto& b_args = b->AsFunctionCall()->args()->contents();
-      std::string_view a_name;
-      std::string_view b_name;
+      std::experimental::string_view a_name;
+      std::experimental::string_view b_name;
       if (!a_args.empty())
         a_name = a_args[0]->AsLiteral()->value().value();
       if (!b_args.empty())
         b_name = b_args[0]->AsLiteral()->value().value();
 
-      auto is_absolute = [](std::string_view import) {
+      auto is_absolute = [](std::experimental::string_view import) {
         return import.size() >= 3 && import[0] == '"' && import[1] == '/' &&
                import[2] == '/';
       };
Index: beta/tools/gn/src/gn/command_help.cc
===================================================================
--- beta.orig/tools/gn/src/gn/command_help.cc
+++ beta/tools/gn/src/gn/command_help.cc
@@ -212,7 +212,7 @@ void PrintAllHelp() {
 bool PrintHelpOnSwitch(const std::string& what) {
   const switches::SwitchInfoMap& all = switches::GetSwitches();
   switches::SwitchInfoMap::const_iterator found =
-      all.find(std::string_view(what));
+      all.find(std::experimental::string_view(what));
   if (found == all.end())
     return false;
   PrintLongHelp(found->second.long_help);
@@ -277,7 +277,7 @@ int RunHelp(const std::vector<std::strin
     what = args[0];
   }
 
-  std::vector<std::string_view> all_help_topics;
+  std::vector<std::experimental::string_view> all_help_topics;
 
   // Special-case ambiguous topics.
   if (what == "args") {
@@ -358,7 +358,7 @@ int RunHelp(const std::vector<std::strin
 
   // No help on this.
   Err(Location(), "No help on \"" + what + "\".").PrintToStdout();
-  std::string_view suggestion = SpellcheckString(what, all_help_topics);
+  std::experimental::string_view suggestion = SpellcheckString(what, all_help_topics);
   if (suggestion.empty()) {
     OutputString("Run `gn help` for a list of available topics.\n",
                  DECORATION_NONE);
Index: beta/tools/gn/src/gn/commands.h
===================================================================
--- beta.orig/tools/gn/src/gn/commands.h
+++ beta/tools/gn/src/gn/commands.h
@@ -8,7 +8,7 @@
 #include <map>
 #include <set>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/values.h"
@@ -102,7 +102,7 @@ struct CommandInfo {
   CommandRunner runner;
 };
 
-using CommandInfoMap = std::map<std::string_view, CommandInfo>;
+using CommandInfoMap = std::map<std::experimental::string_view, CommandInfo>;
 
 const CommandInfoMap& GetCommands();
 
Index: beta/tools/gn/src/gn/create_bundle_target_generator.cc
===================================================================
--- beta.orig/tools/gn/src/gn/create_bundle_target_generator.cc
+++ beta/tools/gn/src/gn/create_bundle_target_generator.cc
@@ -73,7 +73,7 @@ void CreateBundleTargetGenerator::DoRun(
 
 bool CreateBundleTargetGenerator::FillBundleDir(
     const SourceDir& bundle_root_dir,
-    const std::string_view& name,
+    const std::experimental::string_view& name,
     SourceDir* bundle_dir) {
   // All bundle_foo_dir properties are optional. They are only required if they
   // are used in an expansion. The check is performed there.
Index: beta/tools/gn/src/gn/create_bundle_target_generator.h
===================================================================
--- beta.orig/tools/gn/src/gn/create_bundle_target_generator.h
+++ beta/tools/gn/src/gn/create_bundle_target_generator.h
@@ -24,7 +24,7 @@ class CreateBundleTargetGenerator : publ
 
  private:
   bool FillBundleDir(const SourceDir& bundle_root_dir,
-                     const std::string_view& name,
+                     const std::experimental::string_view& name,
                      SourceDir* bundle_dir);
 
   bool FillXcodeExtraAttributes();
Index: beta/tools/gn/src/gn/err.cc
===================================================================
--- beta.orig/tools/gn/src/gn/err.cc
+++ beta/tools/gn/src/gn/err.cc
@@ -17,7 +17,7 @@
 
 namespace {
 
-std::string GetNthLine(const std::string_view& data, int n) {
+std::string GetNthLine(const std::experimental::string_view& data, int n) {
   size_t line_off = Tokenizer::ByteOffsetOfNthLine(data, n);
   size_t end = line_off + 1;
   while (end < data.size() && !Tokenizer::IsNewline(data, end))
Index: beta/tools/gn/src/gn/escape.cc
===================================================================
--- beta.orig/tools/gn/src/gn/escape.cc
+++ beta/tools/gn/src/gn/escape.cc
@@ -41,7 +41,7 @@ const char kShellValid[0x80] = {
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};
 // clang-format on
 
-size_t EscapeStringToString_Space(const std::string_view& str,
+size_t EscapeStringToString_Space(const std::experimental::string_view& str,
                                   const EscapeOptions& options,
                                   char* dest,
                                   bool* needed_quoting) {
@@ -75,7 +75,7 @@ inline bool ShouldEscapeCharForNinja(cha
   return ch == '$' || ch == ' ' || ch == ':';
 }
 
-size_t EscapeStringToString_Ninja(const std::string_view& str,
+size_t EscapeStringToString_Ninja(const std::experimental::string_view& str,
                                   const EscapeOptions& options,
                                   char* dest,
                                   bool* needed_quoting) {
@@ -88,7 +88,7 @@ size_t EscapeStringToString_Ninja(const
   return i;
 }
 
-size_t EscapeStringToString_Depfile(const std::string_view& str,
+size_t EscapeStringToString_Depfile(const std::experimental::string_view& str,
                                     const EscapeOptions& options,
                                     char* dest,
                                     bool* needed_quoting) {
@@ -106,7 +106,7 @@ size_t EscapeStringToString_Depfile(cons
   return i;
 }
 
-size_t EscapeStringToString_NinjaPreformatted(const std::string_view& str,
+size_t EscapeStringToString_NinjaPreformatted(const std::experimental::string_view& str,
                                               char* dest) {
   // Only Ninja-escape $.
   size_t i = 0;
@@ -126,7 +126,7 @@ size_t EscapeStringToString_NinjaPreform
 // See:
 //   http://blogs.msdn.com/b/twistylittlepassagesallalike/archive/2011/04/23/everyone-quotes-arguments-the-wrong-way.aspx
 //   http://blogs.msdn.com/b/oldnewthing/archive/2010/09/17/10063629.aspx
-size_t EscapeStringToString_WindowsNinjaFork(const std::string_view& str,
+size_t EscapeStringToString_WindowsNinjaFork(const std::experimental::string_view& str,
                                              const EscapeOptions& options,
                                              char* dest,
                                              bool* needed_quoting) {
@@ -178,7 +178,7 @@ size_t EscapeStringToString_WindowsNinja
   return i;
 }
 
-size_t EscapeStringToString_PosixNinjaFork(const std::string_view& str,
+size_t EscapeStringToString_PosixNinjaFork(const std::experimental::string_view& str,
                                            const EscapeOptions& options,
                                            char* dest,
                                            bool* needed_quoting) {
@@ -209,7 +209,7 @@ size_t EscapeStringToString_PosixNinjaFo
 }
 
 // Escapes |str| into |dest| and returns the number of characters written.
-size_t EscapeStringToString(const std::string_view& str,
+size_t EscapeStringToString(const std::experimental::string_view& str,
                             const EscapeOptions& options,
                             char* dest,
                             bool* needed_quoting) {
@@ -252,7 +252,7 @@ size_t EscapeStringToString(const std::s
 
 }  // namespace
 
-std::string EscapeString(const std::string_view& str,
+std::string EscapeString(const std::experimental::string_view& str,
                          const EscapeOptions& options,
                          bool* needed_quoting) {
   StackOrHeapBuffer dest(str.size() * kMaxEscapedCharsPerChar);
@@ -261,7 +261,7 @@ std::string EscapeString(const std::stri
 }
 
 void EscapeStringToStream(std::ostream& out,
-                          const std::string_view& str,
+                          const std::experimental::string_view& str,
                           const EscapeOptions& options) {
   StackOrHeapBuffer dest(str.size() * kMaxEscapedCharsPerChar);
   out.write(dest, EscapeStringToString(str, options, dest, nullptr));
Index: beta/tools/gn/src/gn/escape.h
===================================================================
--- beta.orig/tools/gn/src/gn/escape.h
+++ beta/tools/gn/src/gn/escape.h
@@ -6,7 +6,7 @@
 #define TOOLS_GN_ESCAPE_H_
 
 #include <iosfwd>
-#include <string_view>
+#include <experimental/string_view>
 
 enum EscapingMode {
   // No escaping.
@@ -66,14 +66,14 @@ struct EscapeOptions {
 // (if inhibit_quoting was set) quoted will be written to it. This value should
 // be initialized to false by the caller and will be written to only if it's
 // true (the common use-case is for chaining calls).
-std::string EscapeString(const std::string_view& str,
+std::string EscapeString(const std::experimental::string_view& str,
                          const EscapeOptions& options,
                          bool* needed_quoting);
 
 // Same as EscapeString but writes the results to the given stream, saving a
 // copy.
 void EscapeStringToStream(std::ostream& out,
-                          const std::string_view& str,
+                          const std::experimental::string_view& str,
                           const EscapeOptions& options);
 
 #endif  // TOOLS_GN_ESCAPE_H_
Index: beta/tools/gn/src/gn/filesystem_utils.cc
===================================================================
--- beta.orig/tools/gn/src/gn/filesystem_utils.cc
+++ beta/tools/gn/src/gn/filesystem_utils.cc
@@ -81,8 +81,8 @@ inline char NormalizeWindowsPathChar(cha
 
 // Attempts to do a case and slash-insensitive comparison of two 8-bit Windows
 // paths.
-bool AreAbsoluteWindowsPathsEqual(const std::string_view& a,
-                                  const std::string_view& b) {
+bool AreAbsoluteWindowsPathsEqual(const std::experimental::string_view& a,
+                                  const std::experimental::string_view& b) {
   if (a.size() != b.size())
     return false;
 
@@ -95,7 +95,7 @@ bool AreAbsoluteWindowsPathsEqual(const
   return true;
 }
 
-bool DoesBeginWindowsDriveLetter(const std::string_view& path) {
+bool DoesBeginWindowsDriveLetter(const std::experimental::string_view& path) {
   if (path.size() < 3)
     return false;
 
@@ -200,7 +200,7 @@ void AppendFixedAbsolutePathSuffix(const
   }
 }
 
-size_t AbsPathLenWithNoTrailingSlash(const std::string_view& path) {
+size_t AbsPathLenWithNoTrailingSlash(const std::experimental::string_view& path) {
   size_t len = path.size();
 #if defined(OS_WIN)
   size_t min_len = 3;
@@ -222,7 +222,7 @@ std::string FilePathToUTF8(const base::F
 #endif
 }
 
-base::FilePath UTF8ToFilePath(const std::string_view& sp) {
+base::FilePath UTF8ToFilePath(const std::experimental::string_view& sp) {
 #if defined(OS_WIN)
   return base::FilePath(base::UTF8ToUTF16(sp));
 #else
@@ -240,11 +240,11 @@ size_t FindExtensionOffset(const std::st
   return std::string::npos;
 }
 
-std::string_view FindExtension(const std::string* path) {
+std::experimental::string_view FindExtension(const std::string* path) {
   size_t extension_offset = FindExtensionOffset(*path);
   if (extension_offset == std::string::npos)
-    return std::string_view();
-  return std::string_view(&path->data()[extension_offset],
+    return std::experimental::string_view();
+  return std::experimental::string_view(&path->data()[extension_offset],
                           path->size() - extension_offset);
 }
 
@@ -256,17 +256,17 @@ size_t FindFilenameOffset(const std::str
   return 0;  // No filename found means everything was the filename.
 }
 
-std::string_view FindFilename(const std::string* path) {
+std::experimental::string_view FindFilename(const std::string* path) {
   size_t filename_offset = FindFilenameOffset(*path);
   if (filename_offset == 0)
-    return std::string_view(*path);  // Everything is the file name.
-  return std::string_view(&(*path).data()[filename_offset],
+    return std::experimental::string_view(*path);  // Everything is the file name.
+  return std::experimental::string_view(&(*path).data()[filename_offset],
                           path->size() - filename_offset);
 }
 
-std::string_view FindFilenameNoExtension(const std::string* path) {
+std::experimental::string_view FindFilenameNoExtension(const std::string* path) {
   if (path->empty())
-    return std::string_view();
+    return std::experimental::string_view();
   size_t filename_offset = FindFilenameOffset(*path);
   size_t extension_offset = FindExtensionOffset(*path);
 
@@ -276,7 +276,7 @@ std::string_view FindFilenameNoExtension
   else
     name_len = extension_offset - filename_offset - 1;
 
-  return std::string_view(&(*path).data()[filename_offset], name_len);
+  return std::experimental::string_view(&(*path).data()[filename_offset], name_len);
 }
 
 void RemoveFilename(std::string* path) {
@@ -287,18 +287,18 @@ bool EndsWithSlash(const std::string& s)
   return !s.empty() && IsSlash(s[s.size() - 1]);
 }
 
-std::string_view FindDir(const std::string* path) {
+std::experimental::string_view FindDir(const std::string* path) {
   size_t filename_offset = FindFilenameOffset(*path);
   if (filename_offset == 0u)
-    return std::string_view();
-  return std::string_view(path->data(), filename_offset);
+    return std::experimental::string_view();
+  return std::experimental::string_view(path->data(), filename_offset);
 }
 
-std::string_view FindLastDirComponent(const SourceDir& dir) {
+std::experimental::string_view FindLastDirComponent(const SourceDir& dir) {
   const std::string& dir_string = dir.value();
 
   if (dir_string.empty())
-    return std::string_view();
+    return std::experimental::string_view();
   int cur = static_cast<int>(dir_string.size()) - 1;
   DCHECK(dir_string[cur] == '/');
   int end = cur;
@@ -306,9 +306,9 @@ std::string_view FindLastDirComponent(co
 
   for (; cur >= 0; cur--) {
     if (dir_string[cur] == '/')
-      return std::string_view(&dir_string[cur + 1], end - cur - 1);
+      return std::experimental::string_view(&dir_string[cur + 1], end - cur - 1);
   }
-  return std::string_view(&dir_string[0], end);
+  return std::experimental::string_view(&dir_string[0], end);
 }
 
 bool IsStringInOutputDir(const SourceDir& output_dir, const std::string& str) {
@@ -334,7 +334,7 @@ bool EnsureStringIsInOutputDir(const Sou
   return false;
 }
 
-bool IsPathAbsolute(const std::string_view& path) {
+bool IsPathAbsolute(const std::experimental::string_view& path) {
   if (path.empty())
     return false;
 
@@ -355,12 +355,12 @@ bool IsPathAbsolute(const std::string_vi
   return true;
 }
 
-bool IsPathSourceAbsolute(const std::string_view& path) {
+bool IsPathSourceAbsolute(const std::experimental::string_view& path) {
   return (path.size() >= 2 && path[0] == '/' && path[1] == '/');
 }
 
-bool MakeAbsolutePathRelativeIfPossible(const std::string_view& source_root,
-                                        const std::string_view& path,
+bool MakeAbsolutePathRelativeIfPossible(const std::experimental::string_view& source_root,
+                                        const std::experimental::string_view& path,
                                         std::string* dest) {
   DCHECK(IsPathAbsolute(source_root));
   DCHECK(IsPathAbsolute(path));
@@ -504,7 +504,7 @@ base::FilePath MakeAbsoluteFilePathRelat
   return base::FilePath(base::JoinString(relative_components, separator));
 }
 
-void NormalizePath(std::string* path, const std::string_view& source_root) {
+void NormalizePath(std::string* path, const std::experimental::string_view& source_root) {
   char* pathbuf = path->empty() ? nullptr : &(*path)[0];
 
   // top_index is the first character we can modify in the path. Anything
@@ -702,7 +702,7 @@ std::string MakeRelativePath(const std::
 
 std::string RebasePath(const std::string& input,
                        const SourceDir& dest_dir,
-                       const std::string_view& source_root) {
+                       const std::experimental::string_view& source_root) {
   std::string ret;
   DCHECK(source_root.empty() ||
          !base::EndsWith(source_root, "/", base::CompareCase::SENSITIVE));
@@ -715,14 +715,14 @@ std::string RebasePath(const std::string
     std::string input_full;
     std::string dest_full;
     if (input_is_source_path) {
-      input_full.append(source_root);
+      input_full.append(source_root.data(), source_root.size());
       input_full.push_back('/');
       input_full.append(input, 2, std::string::npos);
     } else {
       input_full.append(input);
     }
     if (dest_dir.is_source_absolute()) {
-      dest_full.append(source_root);
+      dest_full.append(source_root.data(), source_root.size());
       dest_full.push_back('/');
       dest_full.append(dest_dir.value(), 2, std::string::npos);
     } else {
@@ -784,7 +784,7 @@ template <typename StringType>
 std::string ResolveRelative(const StringType& input,
                             const std::string& value,
                             bool as_file,
-                            const std::string_view& source_root) {
+                            const std::experimental::string_view& source_root) {
   std::string result;
 
   if (input.size() >= 2 && input[0] == '/' && input[1] == '/') {
@@ -846,15 +846,15 @@ std::string ResolveRelative(const String
 }
 
 // Explicit template instantiation
-template std::string ResolveRelative(const std::string_view& input,
+template std::string ResolveRelative(const std::experimental::string_view& input,
                                      const std::string& value,
                                      bool as_file,
-                                     const std::string_view& source_root);
+                                     const std::experimental::string_view& source_root);
 
 template std::string ResolveRelative(const std::string& input,
                                      const std::string& value,
                                      bool as_file,
-                                     const std::string_view& source_root);
+                                     const std::experimental::string_view& source_root);
 
 std::string DirectoryWithNoLastSlash(const SourceDir& dir) {
   std::string ret;
Index: beta/tools/gn/src/gn/filesystem_utils.h
===================================================================
--- beta.orig/tools/gn/src/gn/filesystem_utils.h
+++ beta/tools/gn/src/gn/filesystem_utils.h
@@ -8,7 +8,7 @@
 #include <stddef.h>
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_path.h"
 #include "gn/settings.h"
@@ -20,7 +20,7 @@ std::string FilePathToUTF8(const base::F
 inline std::string FilePathToUTF8(const base::FilePath& path) {
   return FilePathToUTF8(path.value());
 }
-base::FilePath UTF8ToFilePath(const std::string_view& sp);
+base::FilePath UTF8ToFilePath(const std::experimental::string_view& sp);
 
 // Extensions -----------------------------------------------------------------
 
@@ -31,7 +31,7 @@ size_t FindExtensionOffset(const std::st
 
 // Returns a string piece pointing into the input string identifying the
 // extension. Note that the input pointer must outlive the output.
-std::string_view FindExtension(const std::string* path);
+std::experimental::string_view FindExtension(const std::string* path);
 
 // Filename parts -------------------------------------------------------------
 
@@ -43,10 +43,10 @@ size_t FindFilenameOffset(const std::str
 // Returns a string piece pointing into the input string identifying the
 // file name (following the last slash, including the extension). Note that the
 // input pointer must outlive the output.
-std::string_view FindFilename(const std::string* path);
+std::experimental::string_view FindFilename(const std::string* path);
 
 // Like FindFilename but does not include the extension.
-std::string_view FindFilenameNoExtension(const std::string* path);
+std::experimental::string_view FindFilenameNoExtension(const std::string* path);
 
 // Removes everything after the last slash. The last slash, if any, will be
 // preserved.
@@ -67,11 +67,11 @@ bool EndsWithSlash(const std::string& s)
 // Returns a string piece pointing into the input string identifying the
 // directory name of the given path, including the last slash. Note that the
 // input pointer must outlive the output.
-std::string_view FindDir(const std::string* path);
+std::experimental::string_view FindDir(const std::string* path);
 
 // Returns the substring identifying the last component of the dir, or the
 // empty substring if none. For example "//foo/bar/" -> "bar".
-std::string_view FindLastDirComponent(const SourceDir& dir);
+std::experimental::string_view FindLastDirComponent(const SourceDir& dir);
 
 // Returns true if the given string is in the given output dir. This is pretty
 // stupid and doesn't handle "." and "..", etc., it is designed for a sanity
@@ -96,12 +96,12 @@ bool EnsureStringIsInOutputDir(const Sou
 // Returns true if the input string is absolute. Double-slashes at the
 // beginning are treated as source-relative paths. On Windows, this handles
 // paths of both the native format: "C:/foo" and ours "/C:/foo"
-bool IsPathAbsolute(const std::string_view& path);
+bool IsPathAbsolute(const std::experimental::string_view& path);
 
 // Returns true if the input string is source-absolute. Source-absolute
 // paths begin with two forward slashes and resolve as if they are
 // relative to the source root.
-bool IsPathSourceAbsolute(const std::string_view& path);
+bool IsPathSourceAbsolute(const std::experimental::string_view& path);
 
 // Given an absolute path, checks to see if is it is inside the source root.
 // If it is, fills a source-absolute path into the given output and returns
@@ -112,8 +112,8 @@ bool IsPathSourceAbsolute(const std::str
 // ("/C:/"). The source root can end with a slash or not.
 //
 // Note that this does not attempt to normalize slashes in the output.
-bool MakeAbsolutePathRelativeIfPossible(const std::string_view& source_root,
-                                        const std::string_view& path,
+bool MakeAbsolutePathRelativeIfPossible(const std::experimental::string_view& source_root,
+                                        const std::experimental::string_view& path,
                                         std::string* dest);
 
 // Given two absolute paths |base| and |target|, returns a relative path to
@@ -134,7 +134,7 @@ base::FilePath MakeAbsoluteFilePathRelat
 // a leading slash. Otherwise, |path| will retain its relativity. |source_root|
 // must not end with a slash.
 void NormalizePath(std::string* path,
-                   const std::string_view& source_root = std::string_view());
+                   const std::experimental::string_view& source_root = std::experimental::string_view());
 
 // Converts slashes to backslashes for Windows. Keeps the string unchanged
 // for other systems.
@@ -150,7 +150,7 @@ void ConvertPathToSystem(std::string* pa
 std::string RebasePath(
     const std::string& input,
     const SourceDir& dest_dir,
-    const std::string_view& source_root = std::string_view());
+    const std::experimental::string_view& source_root = std::experimental::string_view());
 
 // Resolves a file or dir name (parameter input) relative to
 // value directory. Will return an empty SourceDir/File on error
@@ -169,7 +169,7 @@ template <typename StringType>
 std::string ResolveRelative(const StringType& input,
                             const std::string& value,
                             bool as_file,
-                            const std::string_view& source_root);
+                            const std::experimental::string_view& source_root);
 
 // Resolves source file or directory relative to some given source root. Returns
 // an empty file path on error.
Index: beta/tools/gn/src/gn/filesystem_utils_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/filesystem_utils_unittest.cc
+++ beta/tools/gn/src/gn/filesystem_utils_unittest.cc
@@ -424,7 +424,7 @@ TEST(FilesystemUtils, NormalizePath) {
 }
 
 TEST(FilesystemUtils, RebasePath) {
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
 
   // Degenerate case.
   EXPECT_EQ(".", RebasePath("//", SourceDir("//"), source_root));
@@ -468,84 +468,84 @@ TEST(FilesystemUtils, RebasePath) {
 
   // Check when only |input| is system-absolute
   EXPECT_EQ("foo", RebasePath("/source/root/foo", SourceDir("//"),
-                              std::string_view("/source/root")));
+                              std::experimental::string_view("/source/root")));
   EXPECT_EQ("foo/", RebasePath("/source/root/foo/", SourceDir("//"),
-                               std::string_view("/source/root")));
+                               std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../builddir/Out/Debug",
             RebasePath("/builddir/Out/Debug", SourceDir("//"),
-                       std::string_view("/source/root")));
+                       std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../../builddir/Out/Debug",
             RebasePath("/builddir/Out/Debug", SourceDir("//"),
-                       std::string_view("/source/root/foo")));
+                       std::experimental::string_view("/source/root/foo")));
   EXPECT_EQ("../../../builddir/Out/Debug/",
             RebasePath("/builddir/Out/Debug/", SourceDir("//"),
-                       std::string_view("/source/root/foo")));
+                       std::experimental::string_view("/source/root/foo")));
   EXPECT_EQ("../../path/to/foo", RebasePath("/path/to/foo", SourceDir("//"),
-                                            std::string_view("/source/root")));
+                                            std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../../path/to/foo",
             RebasePath("/path/to/foo", SourceDir("//a"),
-                       std::string_view("/source/root")));
+                       std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("/source/root")));
+                       std::experimental::string_view("/source/root")));
 
   // Check when only |dest_dir| is system-absolute.
   EXPECT_EQ(".", RebasePath("//", SourceDir("/source/root"),
-                            std::string_view("/source/root")));
+                            std::experimental::string_view("/source/root")));
   EXPECT_EQ("foo", RebasePath("//foo", SourceDir("/source/root"),
-                              std::string_view("/source/root")));
+                              std::experimental::string_view("/source/root")));
   EXPECT_EQ("../foo", RebasePath("//foo", SourceDir("/source/root/bar"),
-                                 std::string_view("/source/root")));
+                                 std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../../source/root/foo",
             RebasePath("//foo", SourceDir("/other/source/root"),
-                       std::string_view("/source/root")));
+                       std::experimental::string_view("/source/root")));
   EXPECT_EQ("../../../../source/root/foo",
             RebasePath("//foo", SourceDir("/other/source/root/bar"),
-                       std::string_view("/source/root")));
+                       std::experimental::string_view("/source/root")));
 
   // Check when |input| and |dest_dir| are both system-absolute. Also,
   // in this case |source_root| is never used so set it to a dummy
   // value.
   EXPECT_EQ("foo", RebasePath("/source/root/foo", SourceDir("/source/root"),
-                              std::string_view("/x/y/z")));
+                              std::experimental::string_view("/x/y/z")));
   EXPECT_EQ("foo/", RebasePath("/source/root/foo/", SourceDir("/source/root"),
-                               std::string_view("/x/y/z")));
+                               std::experimental::string_view("/x/y/z")));
   EXPECT_EQ("../../builddir/Out/Debug",
             RebasePath("/builddir/Out/Debug", SourceDir("/source/root"),
-                       std::string_view("/x/y/z")));
+                       std::experimental::string_view("/x/y/z")));
   EXPECT_EQ("../../../builddir/Out/Debug",
             RebasePath("/builddir/Out/Debug", SourceDir("/source/root/foo"),
-                       std::string_view("/source/root/foo")));
+                       std::experimental::string_view("/source/root/foo")));
   EXPECT_EQ("../../../builddir/Out/Debug/",
             RebasePath("/builddir/Out/Debug/", SourceDir("/source/root/foo"),
-                       std::string_view("/source/root/foo")));
+                       std::experimental::string_view("/source/root/foo")));
   EXPECT_EQ("../../path/to/foo",
             RebasePath("/path/to/foo", SourceDir("/source/root"),
-                       std::string_view("/x/y/z")));
+                       std::experimental::string_view("/x/y/z")));
   EXPECT_EQ("../../../path/to/foo",
             RebasePath("/path/to/foo", SourceDir("/source/root/a"),
-                       std::string_view("/x/y/z")));
+                       std::experimental::string_view("/x/y/z")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/path/to/foo", SourceDir("/source/root/a/b"),
-                       std::string_view("/x/y/z")));
+                       std::experimental::string_view("/x/y/z")));
 
 #if defined(OS_WIN)
   // Test corrections while rebasing Windows-style absolute paths.
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("C:/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("/C:/source/root")));
+                       std::experimental::string_view("/C:/source/root")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/C:/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("C:/source/root")));
+                       std::experimental::string_view("C:/source/root")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/C:/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("/c:/source/root")));
+                       std::experimental::string_view("/c:/source/root")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/c:/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("c:/source/root")));
+                       std::experimental::string_view("c:/source/root")));
   EXPECT_EQ("../../../../path/to/foo",
             RebasePath("/c:/path/to/foo", SourceDir("//a/b"),
-                       std::string_view("C:/source/root")));
+                       std::experimental::string_view("C:/source/root")));
 #endif
 }
 
Index: beta/tools/gn/src/gn/function_foreach.cc
===================================================================
--- beta.orig/tools/gn/src/gn/function_foreach.cc
+++ beta/tools/gn/src/gn/function_foreach.cc
@@ -62,7 +62,7 @@ Value RunForEach(Scope* scope,
         Err(args_vector[0].get(), "Expected an identifier for the loop var.");
     return Value();
   }
-  std::string_view loop_var(identifier->value().value());
+  std::experimental::string_view loop_var(identifier->value().value());
 
   // Extract the list to iterate over. Always copy in case the code changes
   // the list variable inside the loop.
Index: beta/tools/gn/src/gn/function_forward_variables_from.cc
===================================================================
--- beta.orig/tools/gn/src/gn/function_forward_variables_from.cc
+++ beta/tools/gn/src/gn/function_forward_variables_from.cc
@@ -43,10 +43,10 @@ void ForwardValuesFromList(Scope* source
     if (value) {
       // Use the storage key for the original value rather than the string in
       // "cur" because "cur" is a temporary that will be deleted, and Scopes
-      // expect a persistent std::string_view (it won't copy). Not doing this
+      // expect a persistent std::experimental::string_view (it won't copy). Not doing this
       // will lead the scope's key to point to invalid memory after this
       // returns.
-      std::string_view storage_key = source->GetStorageKey(cur.string_value());
+      std::experimental::string_view storage_key = source->GetStorageKey(cur.string_value());
       if (storage_key.empty()) {
         // Programmatic value, don't allow copying.
         *err =
Index: beta/tools/gn/src/gn/function_get_path_info.cc
===================================================================
--- beta.orig/tools/gn/src/gn/function_get_path_info.cc
+++ beta/tools/gn/src/gn/function_get_path_info.cc
@@ -77,7 +77,7 @@ std::string GetOnePathInfo(const Setting
       return std::string(FindExtension(&input_string));
     }
     case WHAT_DIR: {
-      std::string_view dir_incl_slash = FindDir(&input_string);
+      std::experimental::string_view dir_incl_slash = FindDir(&input_string);
       if (dir_incl_slash.empty())
         return std::string(".");
       // Trim slash since this function doesn't return trailing slashes. The
Index: beta/tools/gn/src/gn/functions.cc
===================================================================
--- beta.orig/tools/gn/src/gn/functions.cc
+++ beta/tools/gn/src/gn/functions.cc
@@ -135,7 +135,7 @@ bool FillTargetBlockScope(const Scope* s
 
   // Set the target name variable to the current target, and mark it used
   // because we don't want to issue an error if the script ignores it.
-  const std::string_view target_name(variables::kTargetName);
+  const std::experimental::string_view target_name(variables::kTargetName);
   block_scope->SetValue(target_name, Value(function, args[0].string_value()),
                         function);
   block_scope->MarkUsed(target_name);
Index: beta/tools/gn/src/gn/functions.h
===================================================================
--- beta.orig/tools/gn/src/gn/functions.h
+++ beta/tools/gn/src/gn/functions.h
@@ -7,7 +7,7 @@
 
 #include <map>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 class Err;
@@ -441,7 +441,7 @@ struct FunctionInfo {
   bool is_target;
 };
 
-using FunctionInfoMap = std::map<std::string_view, FunctionInfo>;
+using FunctionInfoMap = std::map<std::experimental::string_view, FunctionInfo>;
 
 // Returns the mapping of all built-in functions.
 const FunctionInfoMap& GetFunctions();
Index: beta/tools/gn/src/gn/generated_file_target_generator.cc
===================================================================
--- beta.orig/tools/gn/src/gn/generated_file_target_generator.cc
+++ beta/tools/gn/src/gn/generated_file_target_generator.cc
@@ -68,7 +68,7 @@ bool GeneratedFileTargetGenerator::FillC
 }
 
 bool GeneratedFileTargetGenerator::IsMetadataCollectionTarget(
-    const std::string_view& variable,
+    const std::experimental::string_view& variable,
     const ParseNode* origin) {
   if (contents_defined_) {
     *err_ =
Index: beta/tools/gn/src/gn/generated_file_target_generator.h
===================================================================
--- beta.orig/tools/gn/src/gn/generated_file_target_generator.h
+++ beta/tools/gn/src/gn/generated_file_target_generator.h
@@ -35,7 +35,7 @@ class GeneratedFileTargetGenerator : pub
   // it is okay to set metadata collection variables on this target.
   //
   // Should be called before FillContents().
-  bool IsMetadataCollectionTarget(const std::string_view& variable,
+  bool IsMetadataCollectionTarget(const std::experimental::string_view& variable,
                                   const ParseNode* origin);
 
   bool contents_defined_ = false;
Index: beta/tools/gn/src/gn/header_checker.h
===================================================================
--- beta.orig/tools/gn/src/gn/header_checker.h
+++ beta/tools/gn/src/gn/header_checker.h
@@ -10,7 +10,7 @@
 #include <map>
 #include <mutex>
 #include <set>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/atomic_ref_count.h"
Index: beta/tools/gn/src/gn/input_conversion.cc
===================================================================
--- beta.orig/tools/gn/src/gn/input_conversion.cc
+++ beta/tools/gn/src/gn/input_conversion.cc
@@ -108,7 +108,7 @@ Value ParseList(const std::string& input
   return ret;
 }
 
-bool IsIdentifier(const std::string_view& buffer) {
+bool IsIdentifier(const std::experimental::string_view& buffer) {
   DCHECK(buffer.size() > 0);
   if (!Tokenizer::IsIdentifierFirstChar(buffer[0]))
     return false;
@@ -147,13 +147,13 @@ Value ParseJSONValue(const Settings* set
         }
         // Search for the key in the input file. We know it's present because
         // it was parsed by the JSON reader, but we need its location to
-        // construct a std::string_view that can be used as key in the Scope.
+        // construct a std::experimental::string_view that can be used as key in the Scope.
         size_t off = input_file->contents().find("\"" + it.first + "\"");
         if (off == std::string::npos) {
           *err = Err(origin, "Invalid encoding \"" + it.first + "\".");
           return Value();
         }
-        std::string_view key(&input_file->contents()[off + 1], it.first.size());
+        std::experimental::string_view key(&input_file->contents()[off + 1], it.first.size());
         scope->SetValue(key, std::move(parsed_value), origin);
       }
       return Value(origin, std::move(scope));
Index: beta/tools/gn/src/gn/label.cc
===================================================================
--- beta.orig/tools/gn/src/gn/label.cc
+++ beta/tools/gn/src/gn/label.cc
@@ -29,7 +29,7 @@ std::string DirWithNoTrailingSlash(const
 // used. The value is used only for generating error messages.
 bool ComputeBuildLocationFromDep(const Value& input_value,
                                  const SourceDir& current_dir,
-                                 const std::string_view& input,
+                                 const std::experimental::string_view& input,
                                  SourceDir* result,
                                  Err* err) {
   // No rule, use the current location.
@@ -48,7 +48,7 @@ bool ComputeBuildLocationFromDep(const V
 // error messages.
 bool ComputeTargetNameFromDep(const Value& input_value,
                               const SourceDir& computed_location,
-                              const std::string_view& input,
+                              const std::experimental::string_view& input,
                               std::string* result,
                               Err* err) {
   if (!input.empty()) {
@@ -88,13 +88,13 @@ bool ComputeTargetNameFromDep(const Valu
 bool Resolve(const SourceDir& current_dir,
              const Label& current_toolchain,
              const Value& original_value,
-             const std::string_view& input,
+             const std::experimental::string_view& input,
              SourceDir* out_dir,
              std::string* out_name,
              SourceDir* out_toolchain_dir,
              std::string* out_toolchain_name,
              Err* err) {
-  // To workaround the problem that std::string_view operator[] doesn't return a
+  // To workaround the problem that std::experimental::string_view operator[] doesn't return a
   // ref.
   const char* input_str = input.data();
   size_t offset = 0;
@@ -111,18 +111,18 @@ bool Resolve(const SourceDir& current_di
   }
 #endif
   size_t path_separator = input.find_first_of(":(", offset);
-  std::string_view location_piece;
-  std::string_view name_piece;
-  std::string_view toolchain_piece;
+  std::experimental::string_view location_piece;
+  std::experimental::string_view name_piece;
+  std::experimental::string_view toolchain_piece;
   if (path_separator == std::string::npos) {
     location_piece = input;
     // Leave name & toolchain piece null.
   } else {
-    location_piece = std::string_view(&input_str[0], path_separator);
+    location_piece = std::experimental::string_view(&input_str[0], path_separator);
 
     size_t toolchain_separator = input.find('(', path_separator);
     if (toolchain_separator == std::string::npos) {
-      name_piece = std::string_view(&input_str[path_separator + 1],
+      name_piece = std::experimental::string_view(&input_str[path_separator + 1],
                                     input.size() - path_separator - 1);
       // Leave location piece null.
     } else if (!out_toolchain_dir) {
@@ -136,7 +136,7 @@ bool Resolve(const SourceDir& current_di
       // Name piece is everything between the two separators. Note that the
       // separators may be the same (e.g. "//foo(bar)" which means empty name.
       if (toolchain_separator > path_separator) {
-        name_piece = std::string_view(&input_str[path_separator + 1],
+        name_piece = std::experimental::string_view(&input_str[path_separator + 1],
                                       toolchain_separator - path_separator - 1);
       }
 
@@ -151,7 +151,7 @@ bool Resolve(const SourceDir& current_di
 
       // Subtract off the two parens to just get the toolchain name.
       toolchain_piece =
-          std::string_view(&input_str[toolchain_separator + 1],
+          std::experimental::string_view(&input_str[toolchain_separator + 1],
                            input.size() - toolchain_separator - 2);
     }
   }
@@ -251,15 +251,15 @@ Implicit names
 )*";
 
 Label::Label(const SourceDir& dir,
-             const std::string_view& name,
+             const std::experimental::string_view& name,
              const SourceDir& toolchain_dir,
-             const std::string_view& toolchain_name)
+             const std::experimental::string_view& toolchain_name)
     : dir_(dir), toolchain_dir_(toolchain_dir) {
   name_.assign(name.data(), name.size());
   toolchain_name_.assign(toolchain_name.data(), toolchain_name.size());
 }
 
-Label::Label(const SourceDir& dir, const std::string_view& name) : dir_(dir) {
+Label::Label(const SourceDir& dir, const std::experimental::string_view& name) : dir_(dir) {
   name_.assign(name.data(), name.size());
 }
 
Index: beta/tools/gn/src/gn/label.h
===================================================================
--- beta.orig/tools/gn/src/gn/label.h
+++ beta/tools/gn/src/gn/label.h
@@ -24,12 +24,12 @@ class Label {
   // Makes a label given an already-separated out path and name.
   // See also Resolve().
   Label(const SourceDir& dir,
-        const std::string_view& name,
+        const std::experimental::string_view& name,
         const SourceDir& toolchain_dir,
-        const std::string_view& toolchain_name);
+        const std::experimental::string_view& toolchain_name);
 
   // Makes a label with an empty toolchain.
-  Label(const SourceDir& dir, const std::string_view& name);
+  Label(const SourceDir& dir, const std::experimental::string_view& name);
 
   // Resolves a string from a build file that may be relative to the
   // current directory into a fully qualified label. On failure returns an
Index: beta/tools/gn/src/gn/label_pattern.cc
===================================================================
--- beta.orig/tools/gn/src/gn/label_pattern.cc
+++ beta/tools/gn/src/gn/label_pattern.cc
@@ -53,7 +53,7 @@ LabelPattern::LabelPattern() : type_(MAT
 
 LabelPattern::LabelPattern(Type type,
                            const SourceDir& dir,
-                           const std::string_view& name,
+                           const std::experimental::string_view& name,
                            const Label& toolchain_label)
     : toolchain_(toolchain_label), type_(type), dir_(dir), name_(name) {}
 
@@ -68,7 +68,7 @@ LabelPattern LabelPattern::GetPattern(co
   if (!value.VerifyTypeIs(Value::STRING, err))
     return LabelPattern();
 
-  std::string_view str(value.string_value());
+  std::experimental::string_view str(value.string_value());
   if (str.empty()) {
     *err = Err(value, "Label pattern must not be empty.");
     return LabelPattern();
@@ -120,8 +120,8 @@ LabelPattern LabelPattern::GetPattern(co
   }
 
   // Extract path and name.
-  std::string_view path;
-  std::string_view name;
+  std::experimental::string_view path;
+  std::experimental::string_view name;
   size_t offset = 0;
 #if defined(OS_WIN)
   if (IsPathAbsolute(str)) {
@@ -136,7 +136,7 @@ LabelPattern LabelPattern::GetPattern(co
 #endif
   size_t colon = str.find(':', offset);
   if (colon == std::string::npos) {
-    path = std::string_view(str);
+    path = std::experimental::string_view(str);
   } else {
     path = str.substr(0, colon);
     name = str.substr(colon + 1);
@@ -173,7 +173,7 @@ LabelPattern LabelPattern::GetPattern(co
   // Resolve the part of the path that's not the wildcard.
   if (!path.empty()) {
     // The non-wildcard stuff better not have a wildcard.
-    if (path.find('*') != std::string_view::npos) {
+    if (path.find('*') != std::experimental::string_view::npos) {
       *err = Err(value, "Label patterns only support wildcard suffixes.",
                  "The pattern contained a '*' that wasn't at the end.");
       return LabelPattern();
@@ -207,7 +207,7 @@ LabelPattern LabelPattern::GetPattern(co
   }
 
   // When we're doing wildcard matching, the name is always empty.
-  return LabelPattern(type, dir, std::string_view(), toolchain_label);
+  return LabelPattern(type, dir, std::experimental::string_view(), toolchain_label);
 }
 
 bool LabelPattern::HasWildcard(const std::string& str) {
Index: beta/tools/gn/src/gn/label_pattern.h
===================================================================
--- beta.orig/tools/gn/src/gn/label_pattern.h
+++ beta/tools/gn/src/gn/label_pattern.h
@@ -5,7 +5,7 @@
 #ifndef TOOLS_GN_LABEL_PATTERN_H_
 #define TOOLS_GN_LABEL_PATTERN_H_
 
-#include <string_view>
+#include <experimental/string_view>
 
 #include "gn/label.h"
 #include "gn/source_dir.h"
@@ -30,7 +30,7 @@ class LabelPattern {
   LabelPattern();
   LabelPattern(Type type,
                const SourceDir& dir,
-               const std::string_view& name,
+               const std::experimental::string_view& name,
                const Label& toolchain_label);
   LabelPattern(const LabelPattern& other);
   ~LabelPattern();
Index: beta/tools/gn/src/gn/lib_file.cc
===================================================================
--- beta.orig/tools/gn/src/gn/lib_file.cc
+++ beta/tools/gn/src/gn/lib_file.cc
@@ -8,7 +8,7 @@
 
 LibFile::LibFile(const SourceFile& source_file) : source_file_(source_file) {}
 
-LibFile::LibFile(const std::string_view& lib_name)
+LibFile::LibFile(const std::experimental::string_view& lib_name)
     : name_(lib_name.data(), lib_name.size()) {
   DCHECK(!lib_name.empty());
 }
Index: beta/tools/gn/src/gn/lib_file.h
===================================================================
--- beta.orig/tools/gn/src/gn/lib_file.h
+++ beta/tools/gn/src/gn/lib_file.h
@@ -9,7 +9,7 @@
 
 #include <algorithm>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "gn/source_file.h"
 
@@ -19,7 +19,7 @@ class LibFile {
  public:
   LibFile() = default;
 
-  explicit LibFile(const std::string_view& lib_name);
+  explicit LibFile(const std::experimental::string_view& lib_name);
   explicit LibFile(const SourceFile& source_file);
 
   bool is_source_file() const { return name_.empty(); }
Index: beta/tools/gn/src/gn/metadata_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/metadata_unittest.cc
+++ beta/tools/gn/src/gn/metadata_unittest.cc
@@ -17,8 +17,8 @@ TEST(MetadataTest, SetContents) {
   b_expected.list_value().push_back(Value(nullptr, true));
 
   Metadata::Contents contents;
-  contents.insert(std::pair<std::string_view, Value>("a", a_expected));
-  contents.insert(std::pair<std::string_view, Value>("b", b_expected));
+  contents.insert(std::pair<std::experimental::string_view, Value>("a", a_expected));
+  contents.insert(std::pair<std::experimental::string_view, Value>("b", b_expected));
 
   metadata.set_contents(std::move(contents));
 
@@ -41,7 +41,7 @@ TEST(MetadataTest, Walk) {
   a_expected.list_value().push_back(Value(nullptr, "bar.h"));
 
   metadata.contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   std::vector<std::string> data_keys;
   data_keys.emplace_back("a");
@@ -75,7 +75,7 @@ TEST(MetadataTest, WalkWithRebase) {
   a_expected.list_value().push_back(Value(nullptr, "foo/bar.h"));
 
   metadata.contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   std::vector<std::string> data_keys;
   data_keys.emplace_back("a");
@@ -117,7 +117,7 @@ TEST(MetadataTest, WalkWithRebaseNonStri
   inner_scope.SetScopeValue(std::move(scope));
   a.list_value().push_back(inner_scope);
 
-  metadata.contents().insert(std::pair<std::string_view, Value>("a", a));
+  metadata.contents().insert(std::pair<std::experimental::string_view, Value>("a", a));
   std::vector<std::string> data_keys;
   data_keys.emplace_back("a");
   std::vector<std::string> walk_keys;
@@ -162,7 +162,7 @@ TEST(MetadataTest, WalkKeysToWalk) {
   a_expected.list_value().push_back(Value(nullptr, "//target"));
 
   metadata.contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   std::vector<std::string> data_keys;
   std::vector<std::string> walk_keys;
@@ -213,7 +213,7 @@ TEST(MetadataTest, WalkNoKeysWithContent
   a_expected.list_value().push_back(Value(nullptr, "//target"));
 
   metadata.contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   std::vector<std::string> data_keys;
   std::vector<std::string> walk_keys;
Index: beta/tools/gn/src/gn/metadata_walk_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/metadata_walk_unittest.cc
+++ beta/tools/gn/src/gn/metadata_walk_unittest.cc
@@ -17,12 +17,12 @@ TEST(MetadataWalkTest, CollectNoRecurse)
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value b_expected(nullptr, Value::LIST);
   b_expected.list_value().push_back(Value(nullptr, true));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("b", b_expected));
+      std::pair<std::experimental::string_view, Value>("b", b_expected));
 
   one.metadata().set_source_dir(SourceDir("/usr/home/files/"));
 
@@ -30,12 +30,12 @@ TEST(MetadataWalkTest, CollectNoRecurse)
   Value a_2_expected(nullptr, Value::LIST);
   a_2_expected.list_value().push_back(Value(nullptr, "bar"));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_2_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_2_expected));
 
   Value b_2_expected(nullptr, Value::LIST);
   b_2_expected.list_value().push_back(Value(nullptr, false));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("b", b_2_expected));
+      std::pair<std::experimental::string_view, Value>("b", b_2_expected));
 
   two.metadata().set_source_dir(SourceDir("/usr/home/files/inner"));
 
@@ -75,18 +75,18 @@ TEST(MetadataWalkTest, CollectWithRecurs
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value b_expected(nullptr, Value::LIST);
   b_expected.list_value().push_back(Value(nullptr, true));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("b", b_expected));
+      std::pair<std::experimental::string_view, Value>("b", b_expected));
 
   TestTarget two(setup, "//foo:two", Target::SOURCE_SET);
   Value a_2_expected(nullptr, Value::LIST);
   a_2_expected.list_value().push_back(Value(nullptr, "bar"));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_2_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_2_expected));
 
   one.public_deps().push_back(LabelTargetPair(&two));
 
@@ -124,25 +124,25 @@ TEST(MetadataWalkTest, CollectWithBarrie
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value walk_expected(nullptr, Value::LIST);
   walk_expected.list_value().push_back(
       Value(nullptr, "//foo:two(//toolchain:default)"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("walk", walk_expected));
+      std::pair<std::experimental::string_view, Value>("walk", walk_expected));
 
   TestTarget two(setup, "//foo:two", Target::SOURCE_SET);
   Value a_2_expected(nullptr, Value::LIST);
   a_2_expected.list_value().push_back(Value(nullptr, "bar"));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_2_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_2_expected));
 
   TestTarget three(setup, "//foo:three", Target::SOURCE_SET);
   Value a_3_expected(nullptr, Value::LIST);
   a_3_expected.list_value().push_back(Value(nullptr, "baz"));
   three.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_3_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_3_expected));
 
   one.public_deps().push_back(LabelTargetPair(&two));
   one.public_deps().push_back(LabelTargetPair(&three));
@@ -180,12 +180,12 @@ TEST(MetadataWalkTest, CollectWithError)
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value walk_expected(nullptr, Value::LIST);
   walk_expected.list_value().push_back(Value(nullptr, "//foo:missing"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("walk", walk_expected));
+      std::pair<std::experimental::string_view, Value>("walk", walk_expected));
 
   UniqueVector<const Target*> targets;
   targets.push_back(&one);
Index: beta/tools/gn/src/gn/ninja_rust_binary_target_writer.cc
===================================================================
--- beta.orig/tools/gn/src/gn/ninja_rust_binary_target_writer.cc
+++ beta/tools/gn/src/gn/ninja_rust_binary_target_writer.cc
@@ -249,7 +249,7 @@ void NinjaRustBinaryTargetWriter::WriteR
 
   EscapeOptions lib_escape_opts;
   lib_escape_opts.mode = ESCAPE_NINJA_COMMAND;
-  const std::string_view lib_prefix("lib");
+  const std::experimental::string_view lib_prefix("lib");
 
   // Non-Rust native dependencies.
   for (const auto& nonrustdep : nonrustdeps) {
@@ -257,7 +257,7 @@ void NinjaRustBinaryTargetWriter::WriteR
     path_output_.WriteDir(
         out_, nonrustdep.AsSourceFile(settings_->build_settings()).GetDir(),
         PathOutput::DIR_NO_LAST_SLASH);
-    std::string_view file = FindFilenameNoExtension(&nonrustdep.value());
+    std::experimental::string_view file = FindFilenameNoExtension(&nonrustdep.value());
     if (!file.compare(0, lib_prefix.size(), lib_prefix)) {
       out_ << " -l";
       EscapeStringToStream(out_, file.substr(lib_prefix.size()),
Index: beta/tools/gn/src/gn/operators.cc
===================================================================
--- beta.orig/tools/gn/src/gn/operators.cc
+++ beta/tools/gn/src/gn/operators.cc
@@ -101,7 +101,7 @@ bool ValueDestination::Init(Scope* exec_
   }
 
   // Known to be an accessor.
-  std::string_view base_str = dest_accessor->base().value();
+  std::experimental::string_view base_str = dest_accessor->base().value();
   Value* base =
       exec_scope->GetMutableValue(base_str, Scope::SEARCH_CURRENT, false);
   if (!base) {
Index: beta/tools/gn/src/gn/output_conversion_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/output_conversion_unittest.cc
+++ beta/tools/gn/src/gn/output_conversion_unittest.cc
@@ -100,7 +100,7 @@ TEST_F(OutputConversionTest, StringScope
   // Add some values to the scope.
   Value value(nullptr, "hello");
   new_scope->SetValue("v", value, nullptr);
-  std::string_view private_var_name("_private");
+  std::experimental::string_view private_var_name("_private");
   new_scope->SetValue(private_var_name, value, nullptr);
 
   std::ostringstream result;
@@ -164,7 +164,7 @@ TEST_F(OutputConversionTest, ValueScope)
   // Add some values to the scope.
   Value value(nullptr, "hello");
   new_scope->SetValue("v", value, nullptr);
-  std::string_view private_var_name("_private");
+  std::experimental::string_view private_var_name("_private");
   new_scope->SetValue(private_var_name, value, nullptr);
 
   std::ostringstream result;
Index: beta/tools/gn/src/gn/parse_tree.cc
===================================================================
--- beta.orig/tools/gn/src/gn/parse_tree.cc
+++ beta/tools/gn/src/gn/parse_tree.cc
@@ -36,7 +36,7 @@ enum DepsCategory {
   DEPS_CATEGORY_OTHER,
 };
 
-DepsCategory GetDepsCategory(std::string_view deps) {
+DepsCategory GetDepsCategory(std::experimental::string_view deps) {
   if (deps.length() < 2 || deps[0] != '"' || deps[deps.size() - 1] != '"')
     return DEPS_CATEGORY_OTHER;
 
@@ -49,19 +49,19 @@ DepsCategory GetDepsCategory(std::string
   return DEPS_CATEGORY_RELATIVE;
 }
 
-std::tuple<std::string_view, std::string_view> SplitAtFirst(
-    std::string_view str,
+std::tuple<std::experimental::string_view, std::experimental::string_view> SplitAtFirst(
+    std::experimental::string_view str,
     char c) {
   if (!base::StartsWith(str, "\"", base::CompareCase::SENSITIVE) ||
       !base::EndsWith(str, "\"", base::CompareCase::SENSITIVE))
-    return std::make_tuple(str, std::string_view());
+    return std::make_tuple(str, std::experimental::string_view());
 
   str = str.substr(1, str.length() - 2);
   size_t index_of_first = str.find(c);
   return std::make_tuple(str.substr(0, index_of_first),
-                         index_of_first != std::string_view::npos
+                         index_of_first != std::experimental::string_view::npos
                              ? str.substr(index_of_first + 1)
-                             : std::string_view());
+                             : std::experimental::string_view());
 }
 
 bool IsSortRangeSeparator(const ParseNode* node, const ParseNode* prev) {
@@ -74,7 +74,7 @@ bool IsSortRangeSeparator(const ParseNod
                static_cast<int>(node->comments()->before().size() + 1)));
 }
 
-std::string_view GetStringRepresentation(const ParseNode* node) {
+std::experimental::string_view GetStringRepresentation(const ParseNode* node) {
   DCHECK(node->AsLiteral() || node->AsIdentifier() || node->AsAccessor());
   if (node->AsLiteral())
     return node->AsLiteral()->value().value();
@@ -82,7 +82,7 @@ std::string_view GetStringRepresentation
     return node->AsIdentifier()->value().value();
   else if (node->AsAccessor())
     return node->AsAccessor()->base().value();
-  return std::string_view();
+  return std::experimental::string_view();
 }
 
 }  // namespace
@@ -148,7 +148,7 @@ base::Value ParseNode::CreateJSONNode(co
 }
 
 base::Value ParseNode::CreateJSONNode(const char* type,
-                                      const std::string_view& value) const {
+                                      const std::experimental::string_view& value) const {
   base::Value dict(base::Value::Type::DICTIONARY);
   dict.SetKey(kJsonNodeType, base::Value(type));
   dict.SetKey(kJsonNodeValue, base::Value(value));
@@ -712,8 +712,8 @@ void ListNode::SortList(Comparator compa
 void ListNode::SortAsStringsList() {
   // Sorts alphabetically.
   SortList([](const ParseNode* a, const ParseNode* b) {
-    std::string_view astr = GetStringRepresentation(a);
-    std::string_view bstr = GetStringRepresentation(b);
+    std::experimental::string_view astr = GetStringRepresentation(a);
+    std::experimental::string_view bstr = GetStringRepresentation(b);
     return astr < bstr;
   });
 }
@@ -722,8 +722,8 @@ void ListNode::SortAsDepsList() {
   // Sorts first relative targets, then absolute, each group is sorted
   // alphabetically.
   SortList([](const ParseNode* a, const ParseNode* b) {
-    std::string_view astr = GetStringRepresentation(a);
-    std::string_view bstr = GetStringRepresentation(b);
+    std::experimental::string_view astr = GetStringRepresentation(a);
+    std::experimental::string_view bstr = GetStringRepresentation(b);
     return std::make_pair(GetDepsCategory(astr), SplitAtFirst(astr, ':')) <
            std::make_pair(GetDepsCategory(bstr), SplitAtFirst(bstr, ':'));
   });
@@ -807,7 +807,7 @@ Value LiteralNode::Execute(Scope* scope,
     case Token::FALSE_TOKEN:
       return Value(this, false);
     case Token::INTEGER: {
-      std::string_view s = value_.value();
+      std::experimental::string_view s = value_.value();
       if ((base::StartsWith(s, "0", base::CompareCase::SENSITIVE) &&
            s.size() > 1) ||
           base::StartsWith(s, "-0", base::CompareCase::SENSITIVE)) {
Index: beta/tools/gn/src/gn/parse_tree.h
===================================================================
--- beta.orig/tools/gn/src/gn/parse_tree.h
+++ beta/tools/gn/src/gn/parse_tree.h
@@ -113,7 +113,7 @@ class ParseNode {
   // given type (and value).
   base::Value CreateJSONNode(const char* type) const;
   base::Value CreateJSONNode(const char* type,
-                             const std::string_view& value) const;
+                             const std::experimental::string_view& value) const;
 
  private:
   // Helper function for CreateJSONNode.
Index: beta/tools/gn/src/gn/parser.cc
===================================================================
--- beta.orig/tools/gn/src/gn/parser.cc
+++ beta/tools/gn/src/gn/parser.cc
@@ -290,7 +290,7 @@ ParserHelper Parser::expressions_[] = {
 };
 
 Parser::Parser(const std::vector<Token>& tokens, Err* err)
-    : invalid_token_(Location(), Token::INVALID, std::string_view()),
+    : invalid_token_(Location(), Token::INVALID, std::experimental::string_view()),
       err_(err),
       cur_(0) {
   for (const auto& token : tokens) {
Index: beta/tools/gn/src/gn/path_output.cc
===================================================================
--- beta.orig/tools/gn/src/gn/path_output.cc
+++ beta/tools/gn/src/gn/path_output.cc
@@ -11,7 +11,7 @@
 #include "util/build_config.h"
 
 PathOutput::PathOutput(const SourceDir& current_dir,
-                       const std::string_view& source_root,
+                       const std::experimental::string_view& source_root,
                        EscapingMode escaping)
     : current_dir_(current_dir) {
   inverse_current_dir_ = RebasePath("//", current_dir, source_root);
@@ -65,7 +65,7 @@ void PathOutput::WriteDir(std::ostream&
   } else {
     // DIR_NO_LAST_SLASH mode, just trim the last char.
     WritePathStr(out,
-                 std::string_view(dir.value().data(), dir.value().size() - 1));
+                 std::experimental::string_view(dir.value().data(), dir.value().size() - 1));
   }
 }
 
@@ -104,7 +104,7 @@ void PathOutput::WriteDir(std::ostream&
           file.value()[file.value().size() - 1] == '/') {
         // Trim trailing slash.
         EscapeStringToStream(
-            out, std::string_view(file.value().data(), file.value().size() - 1),
+            out, std::experimental::string_view(file.value().data(), file.value().size() - 1),
             options_);
       } else {
         // Doesn't end with a slash, write the whole thing.
@@ -121,7 +121,7 @@ void PathOutput::WriteFile(std::ostream&
 }
 
 void PathOutput::WriteSourceRelativeString(std::ostream& out,
-                                           const std::string_view& str) const {
+                                           const std::experimental::string_view& str) const {
   if (options_.mode == ESCAPE_NINJA_COMMAND) {
     // Shell escaping needs an intermediate string since it may end up
     // quoting the whole thing.
@@ -132,7 +132,7 @@ void PathOutput::WriteSourceRelativeStri
     intermediate.append(str.data(), str.size());
 
     EscapeStringToStream(
-        out, std::string_view(intermediate.c_str(), intermediate.size()),
+        out, std::experimental::string_view(intermediate.c_str(), intermediate.size()),
         options_);
   } else {
     // Ninja (and none) escaping can avoid the intermediate string and
@@ -143,11 +143,11 @@ void PathOutput::WriteSourceRelativeStri
 }
 
 void PathOutput::WritePathStr(std::ostream& out,
-                              const std::string_view& str) const {
+                              const std::experimental::string_view& str) const {
   DCHECK(str.size() > 0 && str[0] == '/');
 
   if (str.substr(0, current_dir_.value().size()) ==
-      std::string_view(current_dir_.value())) {
+      std::experimental::string_view(current_dir_.value())) {
     // The current dir is a prefix of the output file, so we can strip the
     // prefix and write out the result.
     EscapeStringToStream(out, str.substr(current_dir_.value().size()),
Index: beta/tools/gn/src/gn/path_output.h
===================================================================
--- beta.orig/tools/gn/src/gn/path_output.h
+++ beta/tools/gn/src/gn/path_output.h
@@ -7,7 +7,7 @@
 
 #include <iosfwd>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/macros.h"
 #include "gn/escape.h"
@@ -35,7 +35,7 @@ class PathOutput {
   };
 
   PathOutput(const SourceDir& current_dir,
-             const std::string_view& source_root,
+             const std::experimental::string_view& source_root,
              EscapingMode escaping);
   ~PathOutput();
 
@@ -71,13 +71,13 @@ class PathOutput {
 
   // Backend for WriteFile and WriteDir. This appends the given file or
   // directory string to the file.
-  void WritePathStr(std::ostream& out, const std::string_view& str) const;
+  void WritePathStr(std::ostream& out, const std::experimental::string_view& str) const;
 
  private:
   // Takes the given string and writes it out, appending to the inverse
   // current dir. This assumes leading slashes have been trimmed.
   void WriteSourceRelativeString(std::ostream& out,
-                                 const std::string_view& str) const;
+                                 const std::experimental::string_view& str) const;
 
   SourceDir current_dir_;
 
Index: beta/tools/gn/src/gn/path_output_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/path_output_unittest.cc
+++ beta/tools/gn/src/gn/path_output_unittest.cc
@@ -14,7 +14,7 @@
 
 TEST(PathOutput, Basic) {
   SourceDir build_dir("//out/Debug/");
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
   PathOutput writer(build_dir, source_root, ESCAPE_NONE);
   {
     // Normal source-root path.
@@ -56,7 +56,7 @@ TEST(PathOutput, Basic) {
 // Same as basic but the output dir is the root.
 TEST(PathOutput, BasicInRoot) {
   SourceDir build_dir("//");
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
   PathOutput writer(build_dir, source_root, ESCAPE_NONE);
   {
     // Normal source-root path.
@@ -74,7 +74,7 @@ TEST(PathOutput, BasicInRoot) {
 
 TEST(PathOutput, NinjaEscaping) {
   SourceDir build_dir("//out/Debug/");
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
   PathOutput writer(build_dir, source_root, ESCAPE_NINJA);
   {
     // Spaces and $ in filenames.
@@ -92,7 +92,7 @@ TEST(PathOutput, NinjaEscaping) {
 
 TEST(PathOutput, NinjaForkEscaping) {
   SourceDir build_dir("//out/Debug/");
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
   PathOutput writer(build_dir, source_root, ESCAPE_NINJA_COMMAND);
 
   // Spaces in filenames should get quoted on Windows.
@@ -145,7 +145,7 @@ TEST(PathOutput, NinjaForkEscaping) {
 
 TEST(PathOutput, InhibitQuoting) {
   SourceDir build_dir("//out/Debug/");
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
   PathOutput writer(build_dir, source_root, ESCAPE_NINJA_COMMAND);
   writer.set_inhibit_quoting(true);
 
@@ -169,7 +169,7 @@ TEST(PathOutput, InhibitQuoting) {
 TEST(PathOutput, WriteDir) {
   {
     SourceDir build_dir("//out/Debug/");
-    std::string_view source_root("/source/root");
+    std::experimental::string_view source_root("/source/root");
     PathOutput writer(build_dir, source_root, ESCAPE_NINJA);
     {
       std::ostringstream out;
@@ -259,7 +259,7 @@ TEST(PathOutput, WriteDir) {
   }
   {
     // Empty build dir writer.
-    std::string_view source_root("/source/root");
+    std::experimental::string_view source_root("/source/root");
     PathOutput root_writer(SourceDir("//"), source_root, ESCAPE_NINJA);
     {
       std::ostringstream out;
Index: beta/tools/gn/src/gn/scope.cc
===================================================================
--- beta.orig/tools/gn/src/gn/scope.cc
+++ beta/tools/gn/src/gn/scope.cc
@@ -21,7 +21,7 @@ const unsigned kProcessingImportFlag = 2
 // Returns true if this variable name should be considered private. Private
 // values start with an underscore, and are not imported from "gni" files
 // when processing an import.
-bool IsPrivateVar(const std::string_view& name) {
+bool IsPrivateVar(const std::experimental::string_view& name) {
   return name.empty() || name[0] == '_';
 }
 
@@ -74,13 +74,13 @@ bool Scope::HasValues(SearchNested searc
   return !values_.empty();
 }
 
-const Value* Scope::GetValue(const std::string_view& ident,
+const Value* Scope::GetValue(const std::experimental::string_view& ident,
                              bool counts_as_used) {
   const Scope* found_in_scope = nullptr;
   return GetValueWithScope(ident, counts_as_used, &found_in_scope);
 }
 
-const Value* Scope::GetValueWithScope(const std::string_view& ident,
+const Value* Scope::GetValueWithScope(const std::experimental::string_view& ident,
                                       bool counts_as_used,
                                       const Scope** found_in_scope) {
   // First check for programmatically-provided values.
@@ -110,7 +110,7 @@ const Value* Scope::GetValueWithScope(co
   return nullptr;
 }
 
-Value* Scope::GetMutableValue(const std::string_view& ident,
+Value* Scope::GetMutableValue(const std::experimental::string_view& ident,
                               SearchNested search_mode,
                               bool counts_as_used) {
   // Don't do programmatic values, which are not mutable.
@@ -129,7 +129,7 @@ Value* Scope::GetMutableValue(const std:
   return nullptr;
 }
 
-std::string_view Scope::GetStorageKey(const std::string_view& ident) const {
+std::experimental::string_view Scope::GetStorageKey(const std::experimental::string_view& ident) const {
   RecordMap::const_iterator found = values_.find(ident);
   if (found != values_.end())
     return found->first;
@@ -137,15 +137,15 @@ std::string_view Scope::GetStorageKey(co
   // Search in parent scope.
   if (containing())
     return containing()->GetStorageKey(ident);
-  return std::string_view();
+  return std::experimental::string_view();
 }
 
-const Value* Scope::GetValue(const std::string_view& ident) const {
+const Value* Scope::GetValue(const std::experimental::string_view& ident) const {
   const Scope* found_in_scope = nullptr;
   return GetValueWithScope(ident, &found_in_scope);
 }
 
-const Value* Scope::GetValueWithScope(const std::string_view& ident,
+const Value* Scope::GetValueWithScope(const std::experimental::string_view& ident,
                                       const Scope** found_in_scope) const {
   RecordMap::const_iterator found = values_.find(ident);
   if (found != values_.end()) {
@@ -157,7 +157,7 @@ const Value* Scope::GetValueWithScope(co
   return nullptr;
 }
 
-Value* Scope::SetValue(const std::string_view& ident,
+Value* Scope::SetValue(const std::experimental::string_view& ident,
                        Value v,
                        const ParseNode* set_node) {
   Record& r = values_[ident];  // Clears any existing value.
@@ -166,7 +166,7 @@ Value* Scope::SetValue(const std::string
   return &r.value;
 }
 
-void Scope::RemoveIdentifier(const std::string_view& ident) {
+void Scope::RemoveIdentifier(const std::experimental::string_view& ident) {
   RecordMap::iterator found = values_.find(ident);
   if (found != values_.end())
     values_.erase(found);
@@ -177,7 +177,7 @@ void Scope::RemovePrivateIdentifiers() {
   // currently backed by several different vendor-specific implementations and
   // I'm not sure if all of them support mutating while iterating. Since this
   // is not perf-critical, do the safe thing.
-  std::vector<std::string_view> to_remove;
+  std::vector<std::experimental::string_view> to_remove;
   for (const auto& cur : values_) {
     if (IsPrivateVar(cur.first))
       to_remove.push_back(cur.first);
@@ -203,7 +203,7 @@ const Template* Scope::GetTemplate(const
   return nullptr;
 }
 
-void Scope::MarkUsed(const std::string_view& ident) {
+void Scope::MarkUsed(const std::experimental::string_view& ident) {
   RecordMap::iterator found = values_.find(ident);
   if (found == values_.end()) {
     NOTREACHED();
@@ -227,7 +227,7 @@ void Scope::MarkAllUsed(const std::set<s
   }
 }
 
-void Scope::MarkUnused(const std::string_view& ident) {
+void Scope::MarkUnused(const std::experimental::string_view& ident) {
   RecordMap::iterator found = values_.find(ident);
   if (found == values_.end()) {
     NOTREACHED();
@@ -236,7 +236,7 @@ void Scope::MarkUnused(const std::string
   found->second.used = false;
 }
 
-bool Scope::IsSetButUnused(const std::string_view& ident) const {
+bool Scope::IsSetButUnused(const std::experimental::string_view& ident) const {
   RecordMap::const_iterator found = values_.find(ident);
   if (found != values_.end()) {
     if (!found->second.used) {
@@ -298,7 +298,7 @@ bool Scope::NonRecursiveMergeTo(Scope* d
                                 Err* err) const {
   // Values.
   for (const auto& pair : values_) {
-    const std::string_view& current_name = pair.first;
+    const std::experimental::string_view& current_name = pair.first;
     if (options.skip_private_vars && IsPrivateVar(current_name))
       continue;  // Skip this private var.
     if (!options.excluded_values.empty() &&
Index: beta/tools/gn/src/gn/scope.h
===================================================================
--- beta.orig/tools/gn/src/gn/scope.h
+++ beta/tools/gn/src/gn/scope.h
@@ -38,7 +38,7 @@ class Template;
 // variables. So you should use a non-const containing scope whenever possible.
 class Scope {
  public:
-  using KeyValueMap = std::map<std::string_view, Value>;
+  using KeyValueMap = std::map<std::experimental::string_view, Value>;
   // Holds an owning list of Items.
   using ItemVector = std::vector<std::unique_ptr<Item>>;
 
@@ -59,7 +59,7 @@ class Scope {
     // Returns a non-null value if the given value can be programmatically
     // generated, or NULL if there is none.
     virtual const Value* GetProgrammaticValue(
-        const std::string_view& ident) = 0;
+        const std::experimental::string_view& ident) = 0;
 
    protected:
     Scope* scope_;
@@ -135,11 +135,11 @@ class Scope {
   // found_in_scope is set to the scope that contains the definition of the
   // ident. If the value was provided programmatically (like host_cpu),
   // found_in_scope will be set to null.
-  const Value* GetValue(const std::string_view& ident, bool counts_as_used);
-  const Value* GetValue(const std::string_view& ident) const;
-  const Value* GetValueWithScope(const std::string_view& ident,
+  const Value* GetValue(const std::experimental::string_view& ident, bool counts_as_used);
+  const Value* GetValue(const std::experimental::string_view& ident) const;
+  const Value* GetValueWithScope(const std::experimental::string_view& ident,
                                  const Scope** found_in_scope) const;
-  const Value* GetValueWithScope(const std::string_view& ident,
+  const Value* GetValueWithScope(const std::experimental::string_view& ident,
                                  bool counts_as_used,
                                  const Scope** found_in_scope);
 
@@ -165,28 +165,28 @@ class Scope {
   //    }
   // The 6 should get set on the nested scope rather than modify the value
   // in the outer one.
-  Value* GetMutableValue(const std::string_view& ident,
+  Value* GetMutableValue(const std::experimental::string_view& ident,
                          SearchNested search_mode,
                          bool counts_as_used);
 
-  // Returns the std::string_view used to identify the value. This string piece
+  // Returns the std::experimental::string_view used to identify the value. This string piece
   // will have the same contents as "ident" passed in, but may point to a
-  // different underlying buffer. This is useful because this std::string_view
+  // different underlying buffer. This is useful because this std::experimental::string_view
   // is static and won't be deleted for the life of the program, so it can be
   // used as keys in places that may outlive a temporary. It will return an
   // empty string for programmatic and nonexistant values.
-  std::string_view GetStorageKey(const std::string_view& ident) const;
+  std::experimental::string_view GetStorageKey(const std::experimental::string_view& ident) const;
 
   // The set_node indicates the statement that caused the set, for displaying
   // errors later. Returns a pointer to the value in the current scope (a copy
   // is made for storage).
-  Value* SetValue(const std::string_view& ident,
+  Value* SetValue(const std::experimental::string_view& ident,
                   Value v,
                   const ParseNode* set_node);
 
   // Removes the value with the given identifier if it exists on the current
   // scope. This does not search recursive scopes. Does nothing if not found.
-  void RemoveIdentifier(const std::string_view& ident);
+  void RemoveIdentifier(const std::experimental::string_view& ident);
 
   // Removes from this scope all identifiers and templates that are considered
   // private.
@@ -200,17 +200,17 @@ class Scope {
   const Template* GetTemplate(const std::string& name) const;
 
   // Marks the given identifier as (un)used in the current scope.
-  void MarkUsed(const std::string_view& ident);
+  void MarkUsed(const std::experimental::string_view& ident);
   void MarkAllUsed();
   void MarkAllUsed(const std::set<std::string>& excluded_values);
-  void MarkUnused(const std::string_view& ident);
+  void MarkUnused(const std::experimental::string_view& ident);
 
   // Checks to see if the scope has a var set that hasn't been used. This is
   // called before replacing the var with a different one. It does not check
   // containing scopes.
   //
   // If the identifier is present but hasnn't been used, return true.
-  bool IsSetButUnused(const std::string_view& ident) const;
+  bool IsSetButUnused(const std::experimental::string_view& ident) const;
 
   // Checks the scope to see if any values were set but not used, and fills in
   // the error and returns false if they were.
@@ -338,7 +338,7 @@ class Scope {
     Value value;
   };
 
-  using RecordMap = std::unordered_map<std::string_view, Record>;
+  using RecordMap = std::unordered_map<std::experimental::string_view, Record>;
 
   void AddProvider(ProgrammaticProvider* p);
   void RemoveProvider(ProgrammaticProvider* p);
Index: beta/tools/gn/src/gn/scope_per_file_provider.cc
===================================================================
--- beta.orig/tools/gn/src/gn/scope_per_file_provider.cc
+++ beta/tools/gn/src/gn/scope_per_file_provider.cc
@@ -18,7 +18,7 @@ ScopePerFileProvider::ScopePerFileProvid
 ScopePerFileProvider::~ScopePerFileProvider() = default;
 
 const Value* ScopePerFileProvider::GetProgrammaticValue(
-    const std::string_view& ident) {
+    const std::experimental::string_view& ident) {
   if (ident == variables::kCurrentToolchain)
     return GetCurrentToolchain();
   if (ident == variables::kDefaultToolchain)
Index: beta/tools/gn/src/gn/scope_per_file_provider.h
===================================================================
--- beta.orig/tools/gn/src/gn/scope_per_file_provider.h
+++ beta/tools/gn/src/gn/scope_per_file_provider.h
@@ -21,7 +21,7 @@ class ScopePerFileProvider : public Scop
   ~ScopePerFileProvider() override;
 
   // ProgrammaticProvider implementation.
-  const Value* GetProgrammaticValue(const std::string_view& ident) override;
+  const Value* GetProgrammaticValue(const std::experimental::string_view& ident) override;
 
  private:
   const Value* GetCurrentToolchain();
Index: beta/tools/gn/src/gn/scope_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/scope_unittest.cc
+++ beta/tools/gn/src/gn/scope_unittest.cc
@@ -57,7 +57,7 @@ TEST(Scope, NonRecursiveMergeTo) {
   // Add some values to the scope.
   Value old_value(&assignment, "hello");
   setup.scope()->SetValue("v", old_value, &assignment);
-  std::string_view private_var_name("_private");
+  std::experimental::string_view private_var_name("_private");
   setup.scope()->SetValue(private_var_name, old_value, &assignment);
 
   // Add some templates to the scope.
Index: beta/tools/gn/src/gn/setup.cc
===================================================================
--- beta.orig/tools/gn/src/gn/setup.cc
+++ beta/tools/gn/src/gn/setup.cc
@@ -202,7 +202,7 @@ void DecrementWorkCount() {
 
 #if defined(OS_WIN)
 
-std::u16string SysMultiByteTo16(std::string_view mb) {
+std::u16string SysMultiByteTo16(std::experimental::string_view mb) {
   if (mb.empty())
     return std::u16string();
 
@@ -281,7 +281,7 @@ base::FilePath FindWindowsPython() {
 
   // Search for python.exe in the path.
   for (const auto& component : base::SplitStringPiece(
-           std::u16string_view(full_path.get(), path_length), u";",
+           std::experimental::u16string_view(full_path.get(), path_length), u";",
            base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
     base::FilePath candidate_exe =
         base::FilePath(component).Append(kPythonExeName);
Index: beta/tools/gn/src/gn/source_dir.cc
===================================================================
--- beta.orig/tools/gn/src/gn/source_dir.cc
+++ beta/tools/gn/src/gn/source_dir.cc
@@ -77,7 +77,7 @@ std::string SourceDir::ResolveRelativeAs
     const Value& blame_input_value,
     const StringType& input_value,
     Err* err,
-    const std::string_view& source_root) const {
+    const std::experimental::string_view& source_root) const {
   if (!ValidateResolveInput<StringType>(as_file, blame_input_value, input_value,
                                         err)) {
     return std::string();
@@ -88,7 +88,7 @@ std::string SourceDir::ResolveRelativeAs
 SourceFile SourceDir::ResolveRelativeFile(
     const Value& p,
     Err* err,
-    const std::string_view& source_root) const {
+    const std::experimental::string_view& source_root) const {
   SourceFile ret;
 
   if (!p.VerifyTypeIs(Value::STRING, err))
@@ -105,7 +105,7 @@ SourceFile SourceDir::ResolveRelativeFil
 std::string SourceDir::ResolveRelativeAs(bool as_file,
                                          const Value& v,
                                          Err* err,
-                                         const std::string_view& source_root,
+                                         const std::experimental::string_view& source_root,
                                          const std::string* v_value) const {
   if (!v.VerifyTypeIs(Value::STRING, err))
     return std::string();
@@ -123,7 +123,7 @@ std::string SourceDir::ResolveRelativeAs
 SourceDir SourceDir::ResolveRelativeDir(
     const Value& v,
     Err* err,
-    const std::string_view& source_root) const {
+    const std::experimental::string_view& source_root) const {
   if (!v.VerifyTypeIs(Value::STRING, err))
     return SourceDir();
 
@@ -140,11 +140,11 @@ template std::string SourceDir::ResolveR
     const Value& blame_input_value,
     const std::string& input_value,
     Err* err,
-    const std::string_view& source_root) const;
+    const std::experimental::string_view& source_root) const;
 
 template std::string SourceDir::ResolveRelativeAs(
     bool as_file,
     const Value& blame_input_value,
-    const std::string_view& input_value,
+    const std::experimental::string_view& input_value,
     Err* err,
-    const std::string_view& source_root) const;
+    const std::experimental::string_view& source_root) const;
Index: beta/tools/gn/src/gn/source_dir.h
===================================================================
--- beta.orig/tools/gn/src/gn/source_dir.h
+++ beta/tools/gn/src/gn/source_dir.h
@@ -9,7 +9,7 @@
 
 #include <algorithm>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_path.h"
 #include "base/logging.h"
@@ -47,7 +47,7 @@ class SourceDir {
       bool as_file,
       const Value& v,
       Err* err,
-      const std::string_view& source_root = std::string_view(),
+      const std::experimental::string_view& source_root = std::experimental::string_view(),
       const std::string* v_value = nullptr) const;
 
   // Like ResolveRelativeAs above, but allows to produce result
@@ -58,13 +58,13 @@ class SourceDir {
       const Value& blame_input_value,
       const StringType& input_value,
       Err* err,
-      const std::string_view& source_root = std::string_view()) const;
+      const std::experimental::string_view& source_root = std::experimental::string_view()) const;
 
   // Wrapper for ResolveRelativeAs.
   SourceFile ResolveRelativeFile(
       const Value& p,
       Err* err,
-      const std::string_view& source_root = std::string_view()) const;
+      const std::experimental::string_view& source_root = std::experimental::string_view()) const;
 
   // Wrapper for ResolveRelativeAs.
   template <typename StringType>
@@ -72,7 +72,7 @@ class SourceDir {
       const Value& blame_input_value,
       const StringType& input_value,
       Err* err,
-      const std::string_view& source_root = std::string_view()) const {
+      const std::experimental::string_view& source_root = std::experimental::string_view()) const {
     SourceDir ret;
     ret.value_ = ResolveRelativeAs<StringType>(false, blame_input_value,
                                                input_value, err, source_root);
@@ -84,7 +84,7 @@ class SourceDir {
   SourceDir ResolveRelativeDir(
       const Value& v,
       Err* err,
-      const std::string_view& source_root = std::string_view()) const;
+      const std::experimental::string_view& source_root = std::experimental::string_view()) const;
 
   // Resolves this source file relative to some given source root. Returns
   // an empty file path on error.
@@ -110,19 +110,19 @@ class SourceDir {
   //
   // This function asserts that the directory is actually source-absolute. The
   // return value points into our buffer.
-  std::string_view SourceAbsoluteWithOneSlash() const {
+  std::experimental::string_view SourceAbsoluteWithOneSlash() const {
     CHECK(is_source_absolute());
-    return std::string_view(&value_[1], value_.size() - 1);
+    return std::experimental::string_view(&value_[1], value_.size() - 1);
   }
 
   // Returns a path that does not end with a slash.
   //
   // This function simply returns the reference to the value if the path is a
   // root, e.g. "/" or "//".
-  std::string_view SourceWithNoTrailingSlash() const {
+  std::experimental::string_view SourceWithNoTrailingSlash() const {
     if (value_.size() > 2)
-      return std::string_view(&value_[0], value_.size() - 1);
-    return std::string_view(value_);
+      return std::experimental::string_view(&value_[0], value_.size() - 1);
+    return std::experimental::string_view(value_);
   }
 
   void SwapValue(std::string* v);
Index: beta/tools/gn/src/gn/source_dir_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/source_dir_unittest.cc
+++ beta/tools/gn/src/gn/source_dir_unittest.cc
@@ -13,9 +13,9 @@ TEST(SourceDir, ResolveRelativeFile) {
   Err err;
   SourceDir base("//base/");
 #if defined(OS_WIN)
-  std::string_view source_root("C:/source/root");
+  std::experimental::string_view source_root("C:/source/root");
 #else
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
 #endif
 
   // Empty input is an error.
@@ -116,9 +116,9 @@ TEST(SourceDir, ResolveRelativeDir) {
   Err err;
   SourceDir base("//base/");
 #if defined(OS_WIN)
-  std::string_view source_root("C:/source/root");
+  std::experimental::string_view source_root("C:/source/root");
 #else
-  std::string_view source_root("/source/root");
+  std::experimental::string_view source_root("/source/root");
 #endif
 
   // Empty input is an error.
Index: beta/tools/gn/src/gn/source_file.cc
===================================================================
--- beta.orig/tools/gn/src/gn/source_file.cc
+++ beta/tools/gn/src/gn/source_file.cc
@@ -22,7 +22,7 @@ void AssertValueSourceFileString(const s
 }
 
 SourceFile::Type GetSourceFileType(const std::string& file) {
-  std::string_view extension = FindExtension(&file);
+  std::experimental::string_view extension = FindExtension(&file);
   if (extension == "cc" || extension == "cpp" || extension == "cxx")
     return SourceFile::SOURCE_CPP;
   if (extension == "h" || extension == "hpp" || extension == "hxx" ||
Index: beta/tools/gn/src/gn/source_file.h
===================================================================
--- beta.orig/tools/gn/src/gn/source_file.h
+++ beta/tools/gn/src/gn/source_file.h
@@ -9,7 +9,7 @@
 
 #include <algorithm>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/files/file_path.h"
 #include "base/logging.h"
@@ -78,9 +78,9 @@ class SourceFile {
   //
   // This function asserts that the file is actually source-absolute. The
   // return value points into our buffer.
-  std::string_view SourceAbsoluteWithOneSlash() const {
+  std::experimental::string_view SourceAbsoluteWithOneSlash() const {
     CHECK(is_source_absolute());
-    return std::string_view(&value_[1], value_.size() - 1);
+    return std::experimental::string_view(&value_[1], value_.size() - 1);
   }
 
   bool operator==(const SourceFile& other) const {
Index: beta/tools/gn/src/gn/standard_out.cc
===================================================================
--- beta.orig/tools/gn/src/gn/standard_out.cc
+++ beta/tools/gn/src/gn/standard_out.cc
@@ -6,7 +6,7 @@
 
 #include <stddef.h>
 
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/command_line.h"
Index: beta/tools/gn/src/gn/string_utils.cc
===================================================================
--- beta.orig/tools/gn/src/gn/string_utils.cc
+++ beta/tools/gn/src/gn/string_utils.cc
@@ -117,7 +117,7 @@ bool AppendInterpolatedIdentifier(Scope*
                                   size_t end_offset,
                                   std::string* output,
                                   Err* err) {
-  std::string_view identifier(&input[begin_offset], end_offset - begin_offset);
+  std::experimental::string_view identifier(&input[begin_offset], end_offset - begin_offset);
   const Value* value = scope->GetValue(identifier, true);
   if (!value) {
     // We assume the input points inside the token.
@@ -225,7 +225,7 @@ bool AppendHexByte(Scope* scope,
     return false;
   }
   int value = 0;
-  if (!base::HexStringToInt(std::string_view(&input[*i + 2], 2), &value)) {
+  if (!base::HexStringToInt(std::experimental::string_view(&input[*i + 2], 2), &value)) {
     *err = ErrInsideStringToken(token, dollars_index, *i - dollars_index + 1,
                                 "Could not convert hex value.");
     return false;
@@ -287,8 +287,8 @@ bool ExpandStringLiteral(Scope* scope,
   return true;
 }
 
-size_t EditDistance(const std::string_view& s1,
-                    const std::string_view& s2,
+size_t EditDistance(const std::experimental::string_view& s1,
+                    const std::experimental::string_view& s2,
                     size_t max_edit_distance) {
   // The algorithm implemented below is the "classic"
   // dynamic-programming algorithm for computing the Levenshtein
@@ -329,13 +329,13 @@ size_t EditDistance(const std::string_vi
   return row[n];
 }
 
-std::string_view SpellcheckString(const std::string_view& text,
-                                  const std::vector<std::string_view>& words) {
+std::experimental::string_view SpellcheckString(const std::experimental::string_view& text,
+                                  const std::vector<std::experimental::string_view>& words) {
   const size_t kMaxValidEditDistance = 3u;
 
   size_t min_distance = kMaxValidEditDistance + 1u;
-  std::string_view result;
-  for (std::string_view word : words) {
+  std::experimental::string_view result;
+  for (std::experimental::string_view word : words) {
     size_t distance = EditDistance(word, text, kMaxValidEditDistance);
     if (distance < min_distance) {
       min_distance = distance;
Index: beta/tools/gn/src/gn/string_utils.h
===================================================================
--- beta.orig/tools/gn/src/gn/string_utils.h
+++ beta/tools/gn/src/gn/string_utils.h
@@ -6,7 +6,7 @@
 #define TOOLS_GN_STRING_UTILS_H_
 
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 class Err;
@@ -14,7 +14,7 @@ class Scope;
 class Token;
 class Value;
 
-inline std::string operator+(const std::string& a, const std::string_view& b) {
+inline std::string operator+(const std::string& a, const std::experimental::string_view& b) {
   std::string ret;
   ret.reserve(a.size() + b.size());
   ret.assign(a);
@@ -22,7 +22,7 @@ inline std::string operator+(const std::
   return ret;
 }
 
-inline std::string operator+(const std::string_view& a, const std::string& b) {
+inline std::string operator+(const std::experimental::string_view& a, const std::string& b) {
   std::string ret;
   ret.reserve(a.size() + b.size());
   ret.assign(a.data(), a.size());
@@ -40,15 +40,15 @@ bool ExpandStringLiteral(Scope* scope,
 // Returns the minimum number of inserts, deleted, and replacements of
 // characters needed to transform s1 to s2, or max_edit_distance + 1 if
 // transforming s1 into s2 isn't possible in at most max_edit_distance steps.
-size_t EditDistance(const std::string_view& s1,
-                    const std::string_view& s2,
+size_t EditDistance(const std::experimental::string_view& s1,
+                    const std::experimental::string_view& s2,
                     size_t max_edit_distance);
 
 // Given a string |text| and a vector of correctly-spelled strings |words|,
 // returns the first string in |words| closest to |text|, or an empty
-// std::string_view if none of the strings in |words| is close.
-std::string_view SpellcheckString(const std::string_view& text,
-                                  const std::vector<std::string_view>& words);
+// std::experimental::string_view if none of the strings in |words| is close.
+std::experimental::string_view SpellcheckString(const std::experimental::string_view& text,
+                                  const std::vector<std::experimental::string_view>& words);
 
 // Reads stdin until end-of-data and returns what it read.
 std::string ReadStdin();
Index: beta/tools/gn/src/gn/string_utils_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/string_utils_unittest.cc
+++ beta/tools/gn/src/gn/string_utils_unittest.cc
@@ -144,7 +144,7 @@ TEST(StringUtils, EditDistance) {
 }
 
 TEST(StringUtils, SpellcheckString) {
-  std::vector<std::string_view> words;
+  std::vector<std::experimental::string_view> words;
   words.push_back("your");
   words.push_back("bravado");
   words.push_back("won\'t");
Index: beta/tools/gn/src/gn/switches.h
===================================================================
--- beta.orig/tools/gn/src/gn/switches.h
+++ beta/tools/gn/src/gn/switches.h
@@ -6,7 +6,7 @@
 #define TOOLS_GN_SWITCHES_H_
 
 #include <map>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace switches {
 
@@ -18,7 +18,7 @@ struct SwitchInfo {
   const char* long_help;
 };
 
-using SwitchInfoMap = std::map<std::string_view, SwitchInfo>;
+using SwitchInfoMap = std::map<std::experimental::string_view, SwitchInfo>;
 
 // Returns the mapping of all global switches.
 const SwitchInfoMap& GetSwitches();
Index: beta/tools/gn/src/gn/target_unittest.cc
===================================================================
--- beta.orig/tools/gn/src/gn/target_unittest.cc
+++ beta/tools/gn/src/gn/target_unittest.cc
@@ -1154,12 +1154,12 @@ TEST(TargetTest, CollectMetadataNoRecurs
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value b_expected(nullptr, Value::LIST);
   b_expected.list_value().push_back(Value(nullptr, true));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("b", b_expected));
+      std::pair<std::experimental::string_view, Value>("b", b_expected));
 
   one.metadata().set_source_dir(SourceDir("/usr/home/files/"));
 
@@ -1189,18 +1189,18 @@ TEST(TargetTest, CollectMetadataWithRecu
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value b_expected(nullptr, Value::LIST);
   b_expected.list_value().push_back(Value(nullptr, true));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("b", b_expected));
+      std::pair<std::experimental::string_view, Value>("b", b_expected));
 
   TestTarget two(setup, "//foo:two", Target::SOURCE_SET);
   Value a_2_expected(nullptr, Value::LIST);
   a_2_expected.list_value().push_back(Value(nullptr, "bar"));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_2_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_2_expected));
 
   one.public_deps().push_back(LabelTargetPair(&two));
 
@@ -1231,25 +1231,25 @@ TEST(TargetTest, CollectMetadataWithBarr
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value walk_expected(nullptr, Value::LIST);
   walk_expected.list_value().push_back(
       Value(nullptr, "two"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("walk", walk_expected));
+      std::pair<std::experimental::string_view, Value>("walk", walk_expected));
 
   TestTarget two(setup, "//foo/two:two", Target::SOURCE_SET);
   Value a_2_expected(nullptr, Value::LIST);
   a_2_expected.list_value().push_back(Value(nullptr, "bar"));
   two.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_2_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_2_expected));
 
   TestTarget three(setup, "//foo:three", Target::SOURCE_SET);
   Value a_3_expected(nullptr, Value::LIST);
   a_3_expected.list_value().push_back(Value(nullptr, "baz"));
   three.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_3_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_3_expected));
 
   one.private_deps().push_back(LabelTargetPair(&two));
   one.public_deps().push_back(LabelTargetPair(&three));
@@ -1280,12 +1280,12 @@ TEST(TargetTest, CollectMetadataWithErro
   Value a_expected(nullptr, Value::LIST);
   a_expected.list_value().push_back(Value(nullptr, "foo"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("a", a_expected));
+      std::pair<std::experimental::string_view, Value>("a", a_expected));
 
   Value walk_expected(nullptr, Value::LIST);
   walk_expected.list_value().push_back(Value(nullptr, "//foo:missing"));
   one.metadata().contents().insert(
-      std::pair<std::string_view, Value>("walk", walk_expected));
+      std::pair<std::experimental::string_view, Value>("walk", walk_expected));
 
   std::vector<std::string> data_keys;
   data_keys.push_back("a");
Index: beta/tools/gn/src/gn/template.cc
===================================================================
--- beta.orig/tools/gn/src/gn/template.cc
+++ beta/tools/gn/src/gn/template.cc
@@ -83,7 +83,7 @@ Value Template::Invoke(Scope* scope,
   invoker_value->SetScopeValue(std::move(invocation_scope));
   template_scope.set_source_dir(scope->GetSourceDir());
 
-  const std::string_view target_name(variables::kTargetName);
+  const std::experimental::string_view target_name(variables::kTargetName);
   template_scope.SetValue(
       target_name, Value(invocation, args[0].string_value()), invocation);
 
Index: beta/tools/gn/src/gn/token.cc
===================================================================
--- beta.orig/tools/gn/src/gn/token.cc
+++ beta/tools/gn/src/gn/token.cc
@@ -8,7 +8,7 @@
 
 Token::Token() : type_(INVALID), value_() {}
 
-Token::Token(const Location& location, Type t, const std::string_view& v)
+Token::Token(const Location& location, Type t, const std::experimental::string_view& v)
     : type_(t), value_(v), location_(location) {}
 
 bool Token::IsIdentifierEqualTo(const char* v) const {
Index: beta/tools/gn/src/gn/token.h
===================================================================
--- beta.orig/tools/gn/src/gn/token.h
+++ beta/tools/gn/src/gn/token.h
@@ -5,7 +5,7 @@
 #ifndef TOOLS_GN_TOKEN_H_
 #define TOOLS_GN_TOKEN_H_
 
-#include <string_view>
+#include <experimental/string_view>
 
 #include "gn/location.h"
 
@@ -58,10 +58,10 @@ class Token {
   };
 
   Token();
-  Token(const Location& location, Type t, const std::string_view& v);
+  Token(const Location& location, Type t, const std::experimental::string_view& v);
 
   Type type() const { return type_; }
-  const std::string_view& value() const { return value_; }
+  const std::experimental::string_view& value() const { return value_; }
   const Location& location() const { return location_; }
   void set_location(Location location) { location_ = location; }
   LocationRange range() const {
@@ -78,7 +78,7 @@ class Token {
 
  private:
   Type type_;
-  std::string_view value_;
+  std::experimental::string_view value_;
   Location location_;
 };
 
Index: beta/tools/gn/src/gn/tokenizer.cc
===================================================================
--- beta.orig/tools/gn/src/gn/tokenizer.cc
+++ beta/tools/gn/src/gn/tokenizer.cc
@@ -32,7 +32,7 @@ bool IsScoperChar(char c) {
   return c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}';
 }
 
-Token::Type GetSpecificOperatorType(std::string_view value) {
+Token::Type GetSpecificOperatorType(std::experimental::string_view value) {
   if (value == "=")
     return Token::EQUAL;
   if (value == "+")
@@ -106,7 +106,7 @@ std::vector<Token> Tokenizer::Run() {
       break;
     size_t token_end = cur_;
 
-    std::string_view token_value(&input_.data()[token_begin],
+    std::experimental::string_view token_value(&input_.data()[token_begin],
                                  token_end - token_begin);
 
     if (type == Token::UNCLASSIFIED_OPERATOR) {
@@ -156,7 +156,7 @@ std::vector<Token> Tokenizer::Run() {
 }
 
 // static
-size_t Tokenizer::ByteOffsetOfNthLine(const std::string_view& buf, int n) {
+size_t Tokenizer::ByteOffsetOfNthLine(const std::experimental::string_view& buf, int n) {
   DCHECK_GT(n, 0);
 
   if (n == 1)
@@ -176,7 +176,7 @@ size_t Tokenizer::ByteOffsetOfNthLine(co
 }
 
 // static
-bool Tokenizer::IsNewline(const std::string_view& buffer, size_t offset) {
+bool Tokenizer::IsNewline(const std::experimental::string_view& buffer, size_t offset) {
   DCHECK(offset < buffer.size());
   // We may need more logic here to handle different line ending styles.
   return buffer[offset] == '\n';
Index: beta/tools/gn/src/gn/tokenizer.h
===================================================================
--- beta.orig/tools/gn/src/gn/tokenizer.h
+++ beta/tools/gn/src/gn/tokenizer.h
@@ -7,7 +7,7 @@
 
 #include <stddef.h>
 
-#include <string_view>
+#include <experimental/string_view>
 #include <vector>
 
 #include "base/macros.h"
@@ -40,11 +40,11 @@ class Tokenizer {
   //
   // This is a helper function for error output so that the tokenizer's
   // notion of lines can be used elsewhere.
-  static size_t ByteOffsetOfNthLine(const std::string_view& buf, int n);
+  static size_t ByteOffsetOfNthLine(const std::experimental::string_view& buf, int n);
 
   // Returns true if the given offset of the string piece counts as a newline.
   // The offset must be in the buffer.
-  static bool IsNewline(const std::string_view& buffer, size_t offset);
+  static bool IsNewline(const std::experimental::string_view& buffer, size_t offset);
 
   static bool IsIdentifierFirstChar(char c);
 
@@ -92,7 +92,7 @@ class Tokenizer {
   std::vector<Token> tokens_;
 
   const InputFile* input_file_;
-  const std::string_view input_;
+  const std::experimental::string_view input_;
   Err* err_;
   WhitespaceTransform whitespace_transform_;
   size_t cur_ = 0;  // Byte offset into input buffer.
Index: beta/tools/gn/src/gn/toolchain.h
===================================================================
--- beta.orig/tools/gn/src/gn/toolchain.h
+++ beta/tools/gn/src/gn/toolchain.h
@@ -6,7 +6,7 @@
 #define TOOLS_GN_TOOLCHAIN_H_
 
 #include <memory>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/logging.h"
 #include "gn/item.h"
Index: beta/tools/gn/src/gn/variables.h
===================================================================
--- beta.orig/tools/gn/src/gn/variables.h
+++ beta/tools/gn/src/gn/variables.h
@@ -6,7 +6,7 @@
 #define TOOLS_GN_VARIABLES_H_
 
 #include <map>
-#include <string_view>
+#include <experimental/string_view>
 
 namespace variables {
 
@@ -348,7 +348,7 @@ struct VariableInfo {
   const char* help;
 };
 
-using VariableInfoMap = std::map<std::string_view, VariableInfo>;
+using VariableInfoMap = std::map<std::experimental::string_view, VariableInfo>;
 
 // Returns the built-in readonly variables.
 // Note: this is used only for help so this getter is not threadsafe.
Index: beta/tools/gn/src/gn/visibility.cc
===================================================================
--- beta.orig/tools/gn/src/gn/visibility.cc
+++ beta/tools/gn/src/gn/visibility.cc
@@ -5,7 +5,7 @@
 #include "gn/visibility.h"
 
 #include <memory>
-#include <string_view>
+#include <experimental/string_view>
 
 #include "base/strings/string_util.h"
 #include "base/values.h"
Index: beta/tools/gn/src/gn/visual_studio_writer.cc
===================================================================
--- beta.orig/tools/gn/src/gn/visual_studio_writer.cc
+++ beta/tools/gn/src/gn/visual_studio_writer.cc
@@ -175,13 +175,13 @@ void ParseLinkerOptions(const Target* ta
 // Returns a string piece pointing into the input string identifying the parent
 // directory path, excluding the last slash. Note that the input pointer must
 // outlive the output.
-std::string_view FindParentDir(const std::string* path) {
+std::experimental::string_view FindParentDir(const std::string* path) {
   DCHECK(path && !path->empty());
   for (int i = static_cast<int>(path->size()) - 2; i >= 0; --i) {
     if (IsSlash((*path)[i]))
-      return std::string_view(path->data(), i);
+      return std::experimental::string_view(path->data(), i);
   }
-  return std::string_view();
+  return std::experimental::string_view();
 }
 
 bool FilterTargets(const BuildSettings* build_settings,
@@ -697,7 +697,7 @@ void VisualStudioWriter::WriteFiltersFil
       filter_path_output.WriteFile(target_relative_out, *file_and_type.file);
       std::string target_relative_path = target_relative_out.str();
       ConvertPathToSystem(&target_relative_path);
-      std::string_view filter_path = FindParentDir(&target_relative_path);
+      std::experimental::string_view filter_path = FindParentDir(&target_relative_path);
 
       if (!filter_path.empty()) {
         std::string filter_path_str(filter_path);
@@ -806,9 +806,9 @@ void VisualStudioWriter::ResolveSolution
   root_folder_path_.clear();
 
   // Get all project directories. Create solution folder for each directory.
-  std::map<std::string_view, SolutionEntry*> processed_paths;
+  std::map<std::experimental::string_view, SolutionEntry*> processed_paths;
   for (const std::unique_ptr<SolutionProject>& project : projects_) {
-    std::string_view folder_path = project->label_dir_path;
+    std::experimental::string_view folder_path = project->label_dir_path;
     if (IsSlash(folder_path[folder_path.size() - 1]))
       folder_path = folder_path.substr(0, folder_path.size() - 1);
     auto it = processed_paths.find(folder_path);
@@ -856,7 +856,7 @@ void VisualStudioWriter::ResolveSolution
       continue;
 
     SolutionEntry* folder = solution_folder.get();
-    std::string_view parent_path;
+    std::experimental::string_view parent_path;
     while ((parent_path = FindParentDir(&folder->path)) != root_folder_path_) {
       auto it = processed_paths.find(parent_path);
       if (it != processed_paths.end()) {
Index: beta/tools/gn/src/gn/xcode_object.cc
===================================================================
--- beta.orig/tools/gn/src/gn/xcode_object.cc
+++ beta/tools/gn/src/gn/xcode_object.cc
@@ -141,7 +141,7 @@ const SourceTypeForExt kSourceTypeForExt
     {"y", "sourcecode.yacc"},
 };
 
-const char* GetSourceType(const std::string_view& ext) {
+const char* GetSourceType(const std::experimental::string_view& ext) {
   for (size_t i = 0; i < std::size(kSourceTypeForExt); ++i) {
     if (kSourceTypeForExt[i].ext == ext)
       return kSourceTypeForExt[i].source_type;
@@ -150,11 +150,11 @@ const char* GetSourceType(const std::str
   return "text";
 }
 
-bool HasExplicitFileType(const std::string_view& ext) {
+bool HasExplicitFileType(const std::experimental::string_view& ext) {
   return ext == "dart";
 }
 
-bool IsSourceFileForIndexing(const std::string_view& ext) {
+bool IsSourceFileForIndexing(const std::experimental::string_view& ext) {
   return ext == "c" || ext == "cc" || ext == "cpp" || ext == "cxx" ||
          ext == "m" || ext == "mm";
 }
@@ -468,7 +468,7 @@ void PBXFileReference::Print(std::ostrea
     PrintProperty(out, rules, "explicitFileType", type_);
     PrintProperty(out, rules, "includeInIndex", 0u);
   } else {
-    std::string_view ext = FindExtension(&name_);
+    std::experimental::string_view ext = FindExtension(&name_);
     if (HasExplicitFileType(ext))
       PrintProperty(out, rules, "explicitFileType", GetSourceType(ext));
     else
@@ -548,7 +548,7 @@ PBXFileReference* PBXGroup::AddSourceFil
   }
 
   PBXGroup* group = nullptr;
-  std::string_view component(navigator_path.data(), sep);
+  std::experimental::string_view component(navigator_path.data(), sep);
   for (const auto& child : children_) {
     if (child->Class() != PBXGroupClass)
       continue;
@@ -693,7 +693,7 @@ void PBXProject::AddSourceFile(const std
                                PBXNativeTarget* target) {
   PBXFileReference* file_reference =
       sources_->AddSourceFile(navigator_path, source_path);
-  std::string_view ext = FindExtension(&source_path);
+  std::experimental::string_view ext = FindExtension(&source_path);
   if (!IsSourceFileForIndexing(ext))
     return;
 
@@ -737,7 +737,7 @@ PBXNativeTarget* PBXProject::AddNativeTa
     const std::string& output_type,
     const std::string& shell_script,
     const PBXAttributes& extra_attributes) {
-  std::string_view ext = FindExtension(&output_name);
+  std::experimental::string_view ext = FindExtension(&output_name);
   PBXFileReference* product = static_cast<PBXFileReference*>(
       products_->AddChild(std::make_unique<PBXFileReference>(
           std::string(), output_name,
Index: beta/tools/gn/src/gn/xml_element_writer.cc
===================================================================
--- beta.orig/tools/gn/src/gn/xml_element_writer.cc
+++ beta/tools/gn/src/gn/xml_element_writer.cc
@@ -8,13 +8,13 @@
 
 XmlAttributes::XmlAttributes() = default;
 
-XmlAttributes::XmlAttributes(const std::string_view& attr_key,
-                             const std::string_view& attr_value) {
+XmlAttributes::XmlAttributes(const std::experimental::string_view& attr_key,
+                             const std::experimental::string_view& attr_value) {
   add(attr_key, attr_value);
 }
 
-XmlAttributes& XmlAttributes::add(const std::string_view& attr_key,
-                                  const std::string_view& attr_value) {
+XmlAttributes& XmlAttributes::add(const std::experimental::string_view& attr_key,
+                                  const std::experimental::string_view& attr_value) {
   push_back(std::make_pair(attr_key, attr_value));
   return *this;
 }
@@ -50,7 +50,7 @@ XmlElementWriter::~XmlElementWriter() {
   }
 }
 
-void XmlElementWriter::Text(const std::string_view& content) {
+void XmlElementWriter::Text(const std::experimental::string_view& content) {
   StartContent(false);
   out_ << content;
 }
Index: beta/tools/gn/src/gn/xml_element_writer.h
===================================================================
--- beta.orig/tools/gn/src/gn/xml_element_writer.h
+++ beta/tools/gn/src/gn/xml_element_writer.h
@@ -8,7 +8,7 @@
 #include <memory>
 #include <ostream>
 #include <string>
-#include <string_view>
+#include <experimental/string_view>
 #include <utility>
 #include <vector>
 
@@ -16,14 +16,14 @@
 
 // Vector of XML attribute key-value pairs.
 class XmlAttributes
-    : public std::vector<std::pair<std::string_view, std::string_view>> {
+    : public std::vector<std::pair<std::experimental::string_view, std::experimental::string_view>> {
  public:
   XmlAttributes();
-  XmlAttributes(const std::string_view& attr_key,
-                const std::string_view& attr_value);
+  XmlAttributes(const std::experimental::string_view& attr_key,
+                const std::experimental::string_view& attr_value);
 
-  XmlAttributes& add(const std::string_view& attr_key,
-                     const std::string_view& attr_value);
+  XmlAttributes& add(const std::experimental::string_view& attr_key,
+                     const std::experimental::string_view& attr_value);
 };
 
 // Helper class for writing XML elements. New XML element is started in
@@ -54,7 +54,7 @@ class XmlElementWriter {
   ~XmlElementWriter();
 
   // Writes arbitrary XML element text.
-  void Text(const std::string_view& content);
+  void Text(const std::experimental::string_view& content);
 
   // Starts new XML sub-element. Caller must ensure that parent element outlives
   // its children.
Index: beta/tools/gn/src/gn/rust_values_generator.cc
===================================================================
--- beta.orig/tools/gn/src/gn/rust_values_generator.cc
+++ beta/tools/gn/src/gn/rust_values_generator.cc
@@ -183,7 +183,7 @@ bool RustTargetGenerator::FillAliasedDep
 
     // Insert into the aliased_deps map.
     target_->rust_values().aliased_deps().emplace(std::move(dep_label),
-                                                  pair.first);
+                                                  std::string(pair.first.data(), pair.first.size()));
   }
 
   return true;
